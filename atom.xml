<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>费默 - 分享</title>
  
  <subtitle>Just run.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilong7676.github.io/"/>
  <updated>2023-10-19T06:40:25.120Z</updated>
  <id>https://lilong7676.github.io/</id>
  
  <author>
    <name>lilong7676</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nodejs中 的 AsyncLocalStorage</title>
    <link href="https://lilong7676.github.io/2023/07/21/javascript/nodejs%E4%B8%AD%E7%9A%84-AsyncLocalStorage/"/>
    <id>https://lilong7676.github.io/2023/07/21/javascript/nodejs中的-AsyncLocalStorage/</id>
    <published>2023-07-21T06:47:16.000Z</published>
    <updated>2023-10-19T06:40:25.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开门见山：什么是-AsyncLocalStorage"><a href="#开门见山：什么是-AsyncLocalStorage" class="headerlink" title="开门见山：什么是 AsyncLocalStorage"></a>开门见山：什么是 AsyncLocalStorage</h2><p>根据 Node.js <a href="https://nodejs.org/docs/latest-v14.x/api/async_hooks.html#async_hooks_class_asynclocalstorage" target="_blank" rel="noopener">官方文档</a>：”This class is used to create asynchronous state within callbacks and promise chains. It allows storing data throughout the lifetime of a web request or any other asynchronous duration. It is similar to thread-local storage in other languages.”，</p><p>为了进一步简化解释，AsyncLocalStorage 允许你在执行异步函数时存储状态，然后使其可用于该函数中的所有代码路径。</p><h3 id="场景：一个案例引入"><a href="#场景：一个案例引入" class="headerlink" title="场景：一个案例引入"></a>场景：一个案例引入</h3><p>如何实现请求的链路追踪？就是说如何确定一个Request从发起到返回处理结束过程中的所有调用路径？一般是通过发起方携带一个唯一请求标识，可以叫traceId，以此来实现链路追踪，实现日志溯源等。</p><h3 id="如何实现请求的链路追踪机制？"><a href="#如何实现请求的链路追踪机制？" class="headerlink" title="如何实现请求的链路追踪机制？"></a>如何实现请求的链路追踪机制？</h3><h4 id="方案一：全局变量-globalTraceId-？"><a href="#方案一：全局变量-globalTraceId-？" class="headerlink" title="方案一：全局变量 globalTraceId ？"></a>方案一：全局变量 globalTraceId ？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Raw Node.js HTTP server</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">let</span> globalTraceId <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0. 处理请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 生成唯一 traceId，每次请求进入，复写 globalTraceId 的值</span></span><br><span class="line">  globalTraceId = generateTraceId()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查用户cookie是否有效</span></span><br><span class="line">  cookieValidator().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 校验成功，返回给用户他需要的内容</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.write(<span class="string">'Congrats! Your damn cookie is the best one!'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  把 traceId 连同 error 上报给异常监控系统</span></span><br><span class="line">    reportError(err, globalTraceId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写状态码500和错误信息等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 server </span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  handleRequest(req, res)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 让 server 和 port:3000 建立 socket 链接，持续接收端口信息</span></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server listening on port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的会出现的问题是由于nodejs单线程执行，第一个请求进来的时候，globalTraceId被赋值，然后进入到异步检查用户cookie的逻辑中，此时node的main stack是空的，事件循环会执行处理下一个请求。此时就会导致globalTraceId被覆写，导致第一个请求的异步检查中错误上报的globalTraceId是错误的。</p><a id="more"></a><h4 id="方案二：直接透传参数"><a href="#方案二：直接透传参数" class="headerlink" title="方案二：直接透传参数"></a>方案二：直接透传参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> traceId = req.headers[<span class="string">'x-trace-id'</span>] || generateTraceId();</span><br><span class="line">  <span class="comment">// 把 traceId 写入 req 这个 object，将参数一路带下去</span></span><br><span class="line">  req.traceId = traceId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同上</span></span><br><span class="line">  cookieValidator().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 校验成功，返回给用户他需要的内容</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  上报 traceId</span></span><br><span class="line">    reportError(err, req.traceId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写状态码500和错误信息等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cookieValidator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do someting</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此后省略监听等操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这种方式简单粗暴，的确可行。问题就是每次都得透传参数，写起来有点麻烦。</p><h3 id="方案三：使用-AsyncLocalStorage-实现"><a href="#方案三：使用-AsyncLocalStorage-实现" class="headerlink" title="方案三：使用 AsyncLocalStorage 实现"></a>方案三：使用 AsyncLocalStorage 实现</h3><p>下面这个例子，实现了一个日志追踪的最简逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">"http"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AsyncLocalStorage &#125; <span class="keyword">from</span> <span class="string">"async_hooks"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个 AsyncLocalStorage 实例，可以初始化多个实例，每一个实例都是互相独立的</span></span><br><span class="line"><span class="keyword">const</span> myAls = <span class="keyword">new</span> AsyncLocalStorage();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logWithId</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出当前的als上下文</span></span><br><span class="line">  <span class="keyword">const</span> context = myAls.getStore();</span><br><span class="line">  <span class="keyword">const</span> id = context.reqId;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id !== <span class="literal">undefined</span> ? id : <span class="string">"-"</span>&#125;</span>:`</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reqId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 我们创建一个模拟的上下文，这个上下文会被传递给 als 回调函数</span></span><br><span class="line">    <span class="keyword">const</span> myContext = &#123;</span><br><span class="line">      reqId: reqId++,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在提供的上下文环境中同步执行一个函数并返回其返回值。这里的 store 在回调函数外部是不可访问的，</span></span><br><span class="line"><span class="comment">    但是在这个回调函数内部创建的任何异步操作都可以访问 store。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    myAls.run(myContext, () =&gt; &#123;</span><br><span class="line">      logWithId(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟一个异步操作</span></span><br><span class="line">      setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        logWithId(<span class="string">"end"</span>);</span><br><span class="line">        res.end();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">http.get(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// 0: start</span></span><br><span class="line"><span class="comment">// 1: start</span></span><br><span class="line"><span class="comment">// 0: end</span></span><br><span class="line"><span class="comment">// 1: end</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是简单了解了下 nodejs 中 AsyncLocalStorage 的初步使用，当然更深层次的理解还需要具体的业务场景来体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开门见山：什么是-AsyncLocalStorage&quot;&gt;&lt;a href=&quot;#开门见山：什么是-AsyncLocalStorage&quot; class=&quot;headerlink&quot; title=&quot;开门见山：什么是 AsyncLocalStorage&quot;&gt;&lt;/a&gt;开门见山：什么是 AsyncLocalStorage&lt;/h2&gt;&lt;p&gt;根据 Node.js &lt;a href=&quot;https://nodejs.org/docs/latest-v14.x/api/async_hooks.html#async_hooks_class_asynclocalstorage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;：”This class is used to create asynchronous state within callbacks and promise chains. It allows storing data throughout the lifetime of a web request or any other asynchronous duration. It is similar to thread-local storage in other languages.”，&lt;/p&gt;
&lt;p&gt;为了进一步简化解释，AsyncLocalStorage 允许你在执行异步函数时存储状态，然后使其可用于该函数中的所有代码路径。&lt;/p&gt;
&lt;h3 id=&quot;场景：一个案例引入&quot;&gt;&lt;a href=&quot;#场景：一个案例引入&quot; class=&quot;headerlink&quot; title=&quot;场景：一个案例引入&quot;&gt;&lt;/a&gt;场景：一个案例引入&lt;/h3&gt;&lt;p&gt;如何实现请求的链路追踪？就是说如何确定一个Request从发起到返回处理结束过程中的所有调用路径？一般是通过发起方携带一个唯一请求标识，可以叫traceId，以此来实现链路追踪，实现日志溯源等。&lt;/p&gt;
&lt;h3 id=&quot;如何实现请求的链路追踪机制？&quot;&gt;&lt;a href=&quot;#如何实现请求的链路追踪机制？&quot; class=&quot;headerlink&quot; title=&quot;如何实现请求的链路追踪机制？&quot;&gt;&lt;/a&gt;如何实现请求的链路追踪机制？&lt;/h3&gt;&lt;h4 id=&quot;方案一：全局变量-globalTraceId-？&quot;&gt;&lt;a href=&quot;#方案一：全局变量-globalTraceId-？&quot; class=&quot;headerlink&quot; title=&quot;方案一：全局变量 globalTraceId ？&quot;&gt;&lt;/a&gt;方案一：全局变量 globalTraceId ？&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Raw Node.js HTTP server&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; http = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; globalTraceId &lt;span class=&quot;comment&quot;&gt;// 全局变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 0. 处理请求的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleRequest&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req, res&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 生成唯一 traceId，每次请求进入，复写 globalTraceId 的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  globalTraceId = generateTraceId()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 检查用户cookie是否有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cookieValidator().then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 校验成功，返回给用户他需要的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;text/plain&#39;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;Congrats! Your damn cookie is the best one!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.end();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//  把 traceId 连同 error 上报给异常监控系统&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reportError(err, globalTraceId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 写状态码500和错误信息等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1. 创建 server &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; server = http.createServer(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;req, res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  handleRequest(req, res)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2. 让 server 和 port:3000 建立 socket 链接，持续接收端口信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Server listening on port 3000&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里的会出现的问题是由于nodejs单线程执行，第一个请求进来的时候，globalTraceId被赋值，然后进入到异步检查用户cookie的逻辑中，此时node的main stack是空的，事件循环会执行处理下一个请求。此时就会导致globalTraceId被覆写，导致第一个请求的异步检查中错误上报的globalTraceId是错误的。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
      <category term="AsyncLocalStorage" scheme="https://lilong7676.github.io/tags/AsyncLocalStorage/"/>
    
  </entry>
  
  <entry>
    <title>如何通过 SSH 在服务器上远程执行命令</title>
    <link href="https://lilong7676.github.io/2023/03/14/Shell%E8%84%9A%E6%9C%AC/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-SSH-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://lilong7676.github.io/2023/03/14/Shell脚本/如何通过-SSH-在服务器上远程执行命令/</id>
    <published>2023-03-14T02:38:04.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近买了一个腾讯云服务器，主要用来托管个人项目，经常执行的操作是ssh登陆到服务器，然后执行某些命令。这里有两个步骤： </p><ol><li>打开ssh登陆软件，然后登陆到服务器</li><li>执行相关命令</li><li>关闭连接</li></ol><p>那有没有办法一气呵成呢？一个命令完成这两个操作，查了下资料，当然可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t username@host <span class="string">'commands'</span></span><br></pre></td></tr></table></figure><p>比如我想看下 root 目录有哪些文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/tencent_ecs root@example.com <span class="string">"ls -a; echo \"done\""</span></span><br></pre></td></tr></table></figure><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230314105027.png?x-oss-process=image/resize,w_800" alt></p><a id="more"></a><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.cnet.com/tech/computing/ssh-tip-send-commands-remotely/" target="_blank" rel="noopener">SSH tip: Send commands remotely</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近买了一个腾讯云服务器，主要用来托管个人项目，经常执行的操作是ssh登陆到服务器，然后执行某些命令。这里有两个步骤： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开ssh登陆软件，然后登陆到服务器&lt;/li&gt;
&lt;li&gt;执行相关命令&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那有没有办法一气呵成呢？一个命令完成这两个操作，查了下资料，当然可以：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -t username@host &lt;span class=&quot;string&quot;&gt;&#39;commands&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;比如我想看下 root 目录有哪些文件：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -i ~/.ssh/tencent_ecs root@example.com &lt;span class=&quot;string&quot;&gt;&quot;ls -a; echo \&quot;done\&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230314105027.png?x-oss-process=image/resize,w_800&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Shell脚本" scheme="https://lilong7676.github.io/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="shell" scheme="https://lilong7676.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>使用peerjs实现一个基于webrtc的简单远程网络摄像头</title>
    <link href="https://lilong7676.github.io/2023/03/03/uncategorized/%E4%BD%BF%E7%94%A8peerjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Ewebrtc%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <id>https://lilong7676.github.io/2023/03/03/uncategorized/使用peerjs实现一个基于webrtc的简单远程网络摄像头/</id>
    <published>2023-03-03T01:38:18.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仓库地址：<a href="https://github.com/lilong7676/cue-live" target="_blank" rel="noopener">https://github.com/lilong7676/cue-live</a><br>技术栈：nextjs + webrtc </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/lilong7676/cue-live&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lilong7676/cue-live&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何构建并发布自己的docker镜像 </title>
    <link href="https://lilong7676.github.io/2023/02/28/uncategorized/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F/"/>
    <id>https://lilong7676.github.io/2023/02/28/uncategorized/如何构建并发布自己的docker镜像/</id>
    <published>2023-02-28T06:28:21.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<p>最近想在云服务器上部署一个自己的 nginx 服务，通过docker 部署最方便。之前也发布过自己的docker镜像，但是时间长了老是忘记具体的命令是啥，这里做一个笔记记录下。  </p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>docker cli</code> 提供了两个命令来完成构建\发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build <span class="comment"># 构建镜像</span></span><br><span class="line">docker pull/push <span class="comment"># 拉取/推送镜像</span></span><br></pre></td></tr></table></figure><p>整体流程参考下图：  </p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228143743.png?x-oss-process=image/resize,w_800" alt="docker构建发布流程"></p><h3 id="docker-build-构建镜像"><a href="#docker-build-构建镜像" class="headerlink" title="docker build 构建镜像"></a>docker build 构建镜像</h3><p>首先命令格式<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">来自文档</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p><code>docker build</code>是利用 Dockerfile 内的指令来构建镜像。通常我们会把 Dockerfile 也加入版本管理，所以对镜像的修改操作也会有记录，这相比 <code>docker commit</code>的黑箱操作好很多。Dockerfile 就不细讲了。</p><a id="more"></a><p>下面就以发布一个自定义配置的 nginx 镜像为例子，记录一下操作步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginx &amp;&amp; <span class="built_in">cd</span> nginx</span><br><span class="line">vi Dockerfile</span><br><span class="line">```  </span><br><span class="line">输入如下内容：</span><br><span class="line">![](https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228145132.png?x-oss-process=image/resize,w_800)  </span><br><span class="line"></span><br><span class="line">构建镜像：</span><br><span class="line">```bash</span><br><span class="line">docker build -t lilong7676/nginx:v1 .</span><br></pre></td></tr></table></figure><p>也可以通过以下命令打标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="built_in">local</span>-image:tagname new-repo:tagname</span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">docker tag nginx:v1 lilong7676/nginx:v1</span><br></pre></td></tr></table></figure><p>构建完成后，查看本地镜像列表，可以看到已经打上了标签v1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image list</span><br></pre></td></tr></table></figure><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228145327.png?x-oss-process=image/resize,w_800" alt></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>登陆 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>，创建仓库<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228150507.png?x-oss-process=image/resize,w_800" alt></p><p>发布镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push lilong7676/nginx:v1</span><br></pre></td></tr></table></figure><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228151436.png?x-oss-process=image/resize,w_800" alt>  </p><p>docker hub查看：</p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228151455.png?x-oss-process=image/resize,w_800" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想在云服务器上部署一个自己的 nginx 服务，通过docker 部署最方便。之前也发布过自己的docker镜像，但是时间长了老是忘记具体的命令是啥，这里做一个笔记记录下。  &lt;/p&gt;
&lt;h2 id=&quot;构建镜像&quot;&gt;&lt;a href=&quot;#构建镜像&quot; class=&quot;headerlink&quot; title=&quot;构建镜像&quot;&gt;&lt;/a&gt;构建镜像&lt;/h2&gt;&lt;p&gt;&lt;code&gt;docker cli&lt;/code&gt; 提供了两个命令来完成构建\发布：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build &lt;span class=&quot;comment&quot;&gt;# 构建镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker pull/push &lt;span class=&quot;comment&quot;&gt;# 拉取/推送镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;整体流程参考下图：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230228143743.png?x-oss-process=image/resize,w_800&quot; alt=&quot;docker构建发布流程&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;docker-build-构建镜像&quot;&gt;&lt;a href=&quot;#docker-build-构建镜像&quot; class=&quot;headerlink&quot; title=&quot;docker build 构建镜像&quot;&gt;&lt;/a&gt;docker build 构建镜像&lt;/h3&gt;&lt;p&gt;首先命令格式&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/build/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来自文档&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build [OPTIONS] PATH | URL | -&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt;是利用 Dockerfile 内的指令来构建镜像。通常我们会把 Dockerfile 也加入版本管理，所以对镜像的修改操作也会有记录，这相比 &lt;code&gt;docker commit&lt;/code&gt;的黑箱操作好很多。Dockerfile 就不细讲了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编译并运行 Chrome Devtools Frontend</title>
    <link href="https://lilong7676.github.io/2023/01/12/javascript/%E7%BC%96%E8%AF%91%E5%B9%B6%E8%BF%90%E8%A1%8C-Chrome-Devtools-Frontend/"/>
    <id>https://lilong7676.github.io/2023/01/12/javascript/编译并运行-Chrome-Devtools-Frontend/</id>
    <published>2023-01-12T01:59:51.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="Chrome-DevTools-工作原理简单介绍"><a href="#Chrome-DevTools-工作原理简单介绍" class="headerlink" title="Chrome DevTools 工作原理简单介绍"></a>Chrome DevTools 工作原理简单介绍</h4></blockquote><p>Devtools 不只是我们在浏览器中按F12所打开的调试界面，它是 Chromium 的一部分，在 Electron 中也有集成。  </p><p>Devtools 主要由四部分组成：  </p><ul><li><a href="https://github.com/ChromeDevTools/devtools-frontend" target="_blank" rel="noopener">Frontend</a>: 调试器前端，默认由 Chromium 内核层集成，DevTools Frontend 是一个 Web 应用程序，就是 JS + CSS + HTML 组成的；</li><li><a href="https://github.com/ChromeDevTools/devtools-frontend/tree/main/v8" target="_blank" rel="noopener">Backend</a>: 调试器后端，广义上主要由 Chromium、V8 或 Node.js(v8)提供，用来与 Frontend 连接与通信;</li><li><a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">Protocol</a>: 通信协议,调试器前端和后端通过此协议通信，协议遵循 <a href="https://www.jianshu.com/p/49cd5c9a1664" target="_blank" rel="noopener">JSON RPC2.0</a> 规范;</li><li><a href="https://github.com/ChromeDevTools/devtools-frontend/blob/b29da32422767c87749ca8132c2c0c8f378da6d7/front_end/core/sdk/Connections.ts#L13" target="_blank" rel="noopener">Connection</a>: 连接层，目前有 <code>WebSocketConnection</code>、<code>StubConnection</code>、<code>MainConnection</code> 三种连接方式，查看其他<a href="https://zhaomenghuan.js.org/blog/chrome-devtools-frontend-analysis-of-principle.html#devtools-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">资料</a>，也有说是消息通道，即 Embedder Channel、WebSocket Channel、Chrome Extensions Channel、USB/ADB Channel，但是我在当前的版本没有找到这部分代码；  </li></ul><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112104133.png?x-oss-process=image/resize,w_800" alt="devtools 图示"></p><a id="more"></a><blockquote><h4 id="Devtools-Frontend-编译"><a href="#Devtools-Frontend-编译" class="headerlink" title="Devtools Frontend 编译"></a>Devtools Frontend 编译</h4></blockquote><ol><li><p>clone devtools-frontend 源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:ChromeDevTools/devtools-frontend.git</span><br></pre></td></tr></table></figure></li><li><p>安装 depot_tools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须安装此工具才能编译 devtools-frontend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 depot_tools 源码</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其添加到本机环境变量中</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/depot_tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量修改立即生效</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>只检出 DevTools frontend 的代码，因为 DevTools Frontend 可独立于 Chromium 作为独立项目构建，并且如果不执行这一步，编译会报错：<code>gn.py: Could not find checkout in any parent of the current path.This must be run inside a checkout.</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir devtools</span><br><span class="line">$ <span class="built_in">cd</span> devtools</span><br><span class="line">$ fetch devtools-frontend</span><br><span class="line"><span class="comment"># 注意，上一步可能会由于网络问题导致 git 相关操作失败，可通过配置 git 和终端代理解决</span></span><br></pre></td></tr></table></figure></li><li><p>构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> devtools-frontend</span><br><span class="line">$ gn gen out/Default</span><br><span class="line">$ autoninja -C out/Default</span><br><span class="line"><span class="comment"># 构建产物在 devtools-frontend/devtools/devtools-frontend/out/Default 文件夹中</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><h4 id="运行-devtools-frontend-产物"><a href="#运行-devtools-frontend-产物" class="headerlink" title="运行 devtools frontend 产物"></a>运行 devtools frontend 产物</h4></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到构建产物目录</span></span><br><span class="line">$ <span class="built_in">cd</span> out/Default/gen/front_end</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve 构建产物</span></span><br><span class="line">$ npx http-server</span><br></pre></td></tr></table></figure><p>查看构建产物目录，这几个 html 其实就是调试前端面板：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112111618.png?x-oss-process=image/resize,w_800,h_600" alt="构建产物目录"></p><p>比如打开 <code>http://127.0.0.1:8080/devtools_app.html</code>，就是我们熟悉的 web 页面调试界面：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112111832.png?x-oss-process=image/resize,w_800" alt>  </p><p>也可以自己尝试打开其他html，如 <code>http://127.0.0.1:8080/node_app.html</code>，<code>http://127.0.0.1:8080/inspector.html</code>等  </p><blockquote><h4 id="结合-node-inspect-来调试-nodejs-代码"><a href="#结合-node-inspect-来调试-nodejs-代码" class="headerlink" title="结合 node inspect 来调试 nodejs 代码"></a>结合 node inspect 来调试 nodejs 代码</h4></blockquote><p>如<a href="https://lilong7676.github.io/2023/01/10/uncategorized/%E4%BD%BF%E7%94%A8-ChromeRemoteInterface-%E8%B0%83%E8%AF%95-nodejs-%E4%BB%A3%E7%A0%81/#%E5%87%86%E5%A4%87%E5%BE%85%E8%B0%83%E8%AF%95%E7%9A%84-nodejs-%E5%AE%9E%E4%BE%8B">上一篇</a>所讲，先准备带调试的 nodejs 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --inspect=9222 <span class="keyword">for</span>-inspect.js</span><br></pre></td></tr></table></figure><p>然后访问 <code>http://localhost:9222/json</code> 获取到 <code>devtoolsFrontendUrl</code>，类似于 <code>devtools://devtools/bundled/js_app.html?experiments=true&amp;v8only=true&amp;ws=localhost:9222/8c4626a1-2903-4da8-9759-5de3c74c3a35</code>  </p><p>只需要将其 <code>query</code> 参数拼接到 <code>http://127.0.0.1:8080/***.html</code>后面即可，拼接后类似于 <code>http://127.0.0.1:8080/inspector.html?experiments=true&amp;v8only=true&amp;ws=localhost:9222/8c4626a1-2903-4da8-9759-5de3c74c3a35</code>，在浏览器中打开后的效果如图：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112135350.png?x-oss-process=image/resize,w_800" alt></p><blockquote><h4 id="从-devtools-中查看-Chrome-Devtools-Protocol-🧐"><a href="#从-devtools-中查看-Chrome-Devtools-Protocol-🧐" class="headerlink" title="从 devtools 中查看 Chrome Devtools Protocol 🧐"></a>从 devtools 中查看 Chrome Devtools Protocol 🧐</h4></blockquote><p>在 <code>Settings -&gt; Experiments</code> 中打开 <code>Protocol Monitor</code> 选项：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112140245.png?x-oss-process=image/resize,w_800" alt="打开 Protocol Monitor 选项"></p><p>显示 <code>Protocol Monitor</code>：<img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112140441.png?x-oss-process=image/resize,w_800" alt></p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112141045.png?x-oss-process=image/resize,w_800" alt="CDP"></p><blockquote><h4 id="定制调试面板的显示，只需要-console、source、network-面板"><a href="#定制调试面板的显示，只需要-console、source、network-面板" class="headerlink" title="定制调试面板的显示，只需要 console、source、network 面板"></a>定制调试面板的显示，只需要 console、source、network 面板</h4></blockquote><blockquote><p>很多情况下，我们想自定义调试界面需要显示哪些面板。比如我只需要 console、source、network 这三个面板，不需要其他的，而且全部集成也不太现实，因为加载速度太慢。  </p></blockquote><p>观察其产物的js，这里以 <code>inspector.html</code> 解释：</p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112165907.png?x-oss-process=image/resize,w_800" alt="inspector.html"></p><p>说明其入口 js 为 <code>./entrypoints/inspector/inspector.ts</code>，查看其原始代码：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112172446.png?x-oss-process=image/resize,w_800" alt><br>这里能看出来，<code>inspector_app</code> 相比 <code>devtools_app</code> 增加了 <code>screencast</code> 面板的功能。  <img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112165907.png?x-oss-process%3Dimage%2Fresize%2Cw_800" alt="Alt text"><br>所以我们大致得出结论，如果想要定制调试面板的现实，只需要修改对应 <code>entrypoints/***_app</code> 下的代码即可。</p><blockquote><h4 id="改造-devtools-app"><a href="#改造-devtools-app" class="headerlink" title="改造 devtools_app"></a>改造 devtools_app</h4></blockquote><p>通过查看 devtools_app 的界面，因为我们只需要 console、source、network 三个面板，所以需要移除多余的调试面板:<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112173848.png?x-oss-process=image/resize,w_800" alt></p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><ul><li><a href="https://www.51cto.com/article/716801.html" target="_blank" rel="noopener">玩转 Chrome DevTools，定制自己的调试工具</a></li><li><a href="https://zhaomenghuan.js.org/blog/chrome-devtools-frontend-analysis-of-principle.html#%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%8F%8A%E7%BC%96%E8%AF%91" target="_blank" rel="noopener">Chrome DevTools Frontend 运行原理浅析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;Chrome-DevTools-工作原理简单介绍&quot;&gt;&lt;a href=&quot;#Chrome-DevTools-工作原理简单介绍&quot; class=&quot;headerlink&quot; title=&quot;Chrome DevTools 工作原理简单介绍&quot;&gt;&lt;/a&gt;Chrome DevTools 工作原理简单介绍&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;Devtools 不只是我们在浏览器中按F12所打开的调试界面，它是 Chromium 的一部分，在 Electron 中也有集成。  &lt;/p&gt;
&lt;p&gt;Devtools 主要由四部分组成：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChromeDevTools/devtools-frontend&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Frontend&lt;/a&gt;: 调试器前端，默认由 Chromium 内核层集成，DevTools Frontend 是一个 Web 应用程序，就是 JS + CSS + HTML 组成的；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChromeDevTools/devtools-frontend/tree/main/v8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Backend&lt;/a&gt;: 调试器后端，广义上主要由 Chromium、V8 或 Node.js(v8)提供，用来与 Frontend 连接与通信;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Protocol&lt;/a&gt;: 通信协议,调试器前端和后端通过此协议通信，协议遵循 &lt;a href=&quot;https://www.jianshu.com/p/49cd5c9a1664&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JSON RPC2.0&lt;/a&gt; 规范;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChromeDevTools/devtools-frontend/blob/b29da32422767c87749ca8132c2c0c8f378da6d7/front_end/core/sdk/Connections.ts#L13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Connection&lt;/a&gt;: 连接层，目前有 &lt;code&gt;WebSocketConnection&lt;/code&gt;、&lt;code&gt;StubConnection&lt;/code&gt;、&lt;code&gt;MainConnection&lt;/code&gt; 三种连接方式，查看其他&lt;a href=&quot;https://zhaomenghuan.js.org/blog/chrome-devtools-frontend-analysis-of-principle.html#devtools-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;资料&lt;/a&gt;，也有说是消息通道，即 Embedder Channel、WebSocket Channel、Chrome Extensions Channel、USB/ADB Channel，但是我在当前的版本没有找到这部分代码；  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230112104133.png?x-oss-process=image/resize,w_800&quot; alt=&quot;devtools 图示&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
      <category term="ChromeDevTools" scheme="https://lilong7676.github.io/tags/ChromeDevTools/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChromeRemoteInterface 调试 nodejs 代码</title>
    <link href="https://lilong7676.github.io/2023/01/10/javascript/%E4%BD%BF%E7%94%A8-ChromeRemoteInterface-%E8%B0%83%E8%AF%95-nodejs-%E4%BB%A3%E7%A0%81/"/>
    <id>https://lilong7676.github.io/2023/01/10/javascript/使用-ChromeRemoteInterface-调试-nodejs-代码/</id>
    <published>2023-01-10T06:59:29.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在调研如何远程调试一个 nodejs 进程，大致调研路径是 Chome DevTolls -&gt; Chrome debugging protocol -&gt; chrome-remote-interface，本文重点介绍下 chrome-remote-interface 的简单使用。 </p></blockquote><p>根据其<a href="https://github.com/cyrus-and/chrome-remote-interface" target="_blank" rel="noopener">文档</a>，这个工具主要是提供一个 js api，在连接到对应的服务端（要调试的端）后，通过 Chrome Debugging Protocol 与之交互。  </p><p>所以其基本的使用分为以下几个步骤：  </p><ul><li>启动 nodejs 实例，并打开调试模式, eg. <code>node --inspect-brk=9222 for-insepct.js</code></li><li>通过 CDP 连接到远程调试实例</li><li>通过 CDP Client 操作远程调试实例</li></ul><a id="more"></a><h4 id="准备待调试的-nodejs-实例"><a href="#准备待调试的-nodejs-实例" class="headerlink" title="准备待调试的 nodejs 实例"></a>准备待调试的 nodejs 实例</h4><p>先新建 <code>for-inspect.js</code>，可以写入任意可执行的代码：  </p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230111114509.png" alt="for-inspect.js"></p><p>执行代码，附加 <code>--inspect-brk=9222</code> 调试参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node --inspect-brk=9222 <span class="keyword">for</span>-insepct.js</span></span><br></pre></td></tr></table></figure><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230110170510.png" alt="执行结果"><br>有关 inspect-brk 参数的作用可以参考 <a href="https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options" target="_blank" rel="noopener">node文档</a>，简单来说就是打开调试模式，并在代码首行断点执行，默认实例调试地址为 localhost:9229<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230110171113.png" alt="inspect-brk 参数"> </p><p>此时，nodejs 已经在 <code>localhost:9222</code> 上启动了调试实例，可以通过访问 <code>http://localhost:9222/json</code> 查看详细信息:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ &#123;</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"node.js instance"</span>,</span><br><span class="line">  <span class="attr">"devtoolsFrontendUrl"</span>: <span class="string">"devtools://devtools/bundled/js_app.html?experiments=true&amp;v8only=true&amp;ws=localhost:9222/4d7174b7-e4cf-4d60-84c5-80f3eed2477d"</span>,</span><br><span class="line">  <span class="attr">"devtoolsFrontendUrlCompat"</span>: <span class="string">"devtools://devtools/bundled/inspector.html?experiments=true&amp;v8only=true&amp;ws=localhost:9222/4d7174b7-e4cf-4d60-84c5-80f3eed2477d"</span>,</span><br><span class="line">  <span class="attr">"faviconUrl"</span>: <span class="string">"https://nodejs.org/static/images/favicons/favicon.ico"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"4d7174b7-e4cf-4d60-84c5-80f3eed2477d"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"for-insepct.js"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"file:///Users/lilonglong/Desktop/long_git/chrome-devtools-analysis/for-insepct.js"</span>,</span><br><span class="line">  <span class="attr">"webSocketDebuggerUrl"</span>: <span class="string">"ws://localhost:9222/4d7174b7-e4cf-4d60-84c5-80f3eed2477d"</span></span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure><p>可通过 Chrome 直接访问 <code>devtoolsFrontendUrl</code>:<img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230110172257.png" alt="Chrome 访问 devtoolsFrontendUrl">  </p><p>当然，可以通过上面的 Chrome 来调试 nodejs 代码，所以此方案不是重点，重点是如何通过代码来远程调试 nodejs 代码。</p><h4 id="通过-chrome-remote-interface-远程调试-nodejs"><a href="#通过-chrome-remote-interface-远程调试-nodejs" class="headerlink" title="通过 chrome-remote-interface 远程调试 nodejs"></a>通过 chrome-remote-interface 远程调试 nodejs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cdp.js</span></span><br><span class="line"><span class="keyword">const</span> CDP = <span class="built_in">require</span>(<span class="string">"chrome-remote-interface"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过默认的连接配置，连接到对应的 调试实例（inspector agent）</span></span><br><span class="line">CDP(<span class="keyword">async</span> (client) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 连接成功，通过 CDP client 即可操作调试实例</span></span><br><span class="line">  <span class="keyword">const</span> &#123; Debugger, Runtime, Network &#125; = client;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 监听 scriptParsed 事件，拿到 script source code</span></span><br><span class="line">    Debugger.on(<span class="string">"scriptParsed"</span>, <span class="keyword">async</span> (params) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; scriptId, url &#125; = params;</span><br><span class="line">      <span class="comment">// console.log(`scriptId: $&#123;scriptId&#125;, url: $&#123;url&#125;`);</span></span><br><span class="line">      <span class="keyword">if</span> (url.startsWith(<span class="string">"file://"</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">await</span> client.Debugger.getScriptSource(&#123; scriptId &#125;);</span><br><span class="line">        <span class="comment">// 打印获取到的 script 源码</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"script source"</span>, source);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听进入到断点事件</span></span><br><span class="line">    Debugger.on(<span class="string">"paused"</span>, (pausedEvent) =&gt; &#123;</span><br><span class="line">      <span class="comment">// pausedEvent 里面包含当前断点的位置以及 callFrames 信息等</span></span><br><span class="line">      <span class="comment">// console.log('pausedEvent ', pausedEvent);</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试实例如果在等待附加调试器，则先继续运行调试实例</span></span><br><span class="line">    <span class="keyword">await</span> Runtime.runIfWaitingForDebugger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求允许使用 agent 的 Debugger 功能</span></span><br><span class="line">    <span class="keyword">await</span> Debugger.enable();</span><br><span class="line">    <span class="comment">// 请求允许使用 agent 的 Runtime 功能</span></span><br><span class="line">    <span class="keyword">await</span> Runtime.enable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">//   // 网络请求域，这里注释的原因是 nodejs v8 不支持调试 Network 域</span></span><br><span class="line">    <span class="comment">//   await Network.enable(&#123; maxPostDataSize: 65536 &#125;);</span></span><br><span class="line">    <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">    <span class="comment">//   console.error('Network attach failed', error);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程执行代码</span></span><br><span class="line">    <span class="keyword">const</span> testValue = <span class="keyword">await</span> Runtime.evaluate(&#123;</span><br><span class="line">      expression: <span class="string">"eval(1 + 1)"</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"evaluate result"</span>, testValue);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20230111113918.png" alt="node cdp.js"></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://chromedevtools.github.io/devtools-protocol/v8/" target="_blank" rel="noopener">v8 CDP 文档</a></li><li><a href="https://blog.cloudflare.com/better-workers-debugging-with-a-network-panel/" target="_blank" rel="noopener">Cloudflare Worker Debugger 设计</a></li><li><a href="https://www.jianshu.com/p/49cd5c9a1664" target="_blank" rel="noopener">JSON-RPC 是什么</a></li><li><a href="https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options" target="_blank" rel="noopener">node debugging guide</a></li><li><a href="https://garnik.medium.com/http-inspector-a-devtools-network-tab-for-node-js-process-5a008d17bf28" target="_blank" rel="noopener">http-inspector — a DevTools Network tab for Node.js process</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/75" target="_blank" rel="noopener">有关 node 不支持调试 network 的讨论</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在调研如何远程调试一个 nodejs 进程，大致调研路径是 Chome DevTolls -&amp;gt; Chrome debugging protocol -&amp;gt; chrome-remote-interface，本文重点介绍下 chrome-remote-interface 的简单使用。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据其&lt;a href=&quot;https://github.com/cyrus-and/chrome-remote-interface&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;，这个工具主要是提供一个 js api，在连接到对应的服务端（要调试的端）后，通过 Chrome Debugging Protocol 与之交互。  &lt;/p&gt;
&lt;p&gt;所以其基本的使用分为以下几个步骤：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动 nodejs 实例，并打开调试模式, eg. &lt;code&gt;node --inspect-brk=9222 for-insepct.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 CDP 连接到远程调试实例&lt;/li&gt;
&lt;li&gt;通过 CDP Client 操作远程调试实例&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
      <category term="ChromeDevTools" scheme="https://lilong7676.github.io/tags/ChromeDevTools/"/>
    
  </entry>
  
  <entry>
    <title>使用 babel 实现一个自创的 js 语法</title>
    <link href="https://lilong7676.github.io/2022/12/09/javascript/%E4%BD%BF%E7%94%A8-babel-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%88%9B%E7%9A%84-js-%E8%AF%AD%E6%B3%95/"/>
    <id>https://lilong7676.github.io/2022/12/09/javascript/使用-babel-实现一个自创的-js-语法/</id>
    <published>2022-12-09T06:39:26.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用-babel-实现用-标记一个函数时，将为函数自动加上调用日志打印的功能"><a href="#用-babel-实现用-标记一个函数时，将为函数自动加上调用日志打印的功能" class="headerlink" title="用 babel 实现用 @!标记一个函数时，将为函数自动加上调用日志打印的功能"></a>用 babel 实现用 <code>@!</code>标记一个函数时，将为函数自动加上调用日志打印的功能</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> @! <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function name:'</span>, <span class="string">'foo'</span>, <span class="string">'date:'</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据<a href="https://babeljs.io/docs/en/babel-parser#output" target="_blank" rel="noopener">文档</a>可知要在 <code>packages/babel-parser</code> 里找逻辑</p><p><strong>注意，请先 fork babel 源码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 babel 源码目录里执行</span></span><br><span class="line">$ make watch <span class="comment"># 编译并 watch</span></span><br><span class="line">$ <span class="built_in">cd</span> packages/babel-parse/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 在 babel-parse 里新建单元测试文件，用来验证逻辑</span></span><br><span class="line">$ touch <span class="built_in">test</span>-parser.js</span><br></pre></td></tr></table></figure><p>test-parser.js 内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test-parser.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"../lib/index.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParser</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// sourceType 可能的值为 "script", "module", or "unambiguous"，</span></span><br><span class="line">  <span class="comment">// 如果是 unambiguous，则 babel 会尝试判断代码中是否包含 import export 语句来确定具体类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">"module"</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">"测试自定义语法 @! parse -&gt; ast"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"should parse"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(getParser(<span class="string">`function @! foo() &#123;&#125;`</span>)()).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可通过下面的命令执行 jest：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过下面的命令执行 jest</span></span><br><span class="line"> $ BABEL_ENV=<span class="built_in">test</span> node_modules/.bin/jest -u packages/babel-parser/<span class="built_in">test</span>/<span class="built_in">test</span>-parser.js</span><br></pre></td></tr></table></figure><p> 执行结果报错信息：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  测试自定义语法 @@ parse -&gt; ast</span><br><span class="line">    ✕ should parse</span><br><span class="line"></span><br><span class="line">测试自定义语法 @@ parse -&gt; ast &gt; should parse</span><br><span class="line">    SyntaxError: Unexpected token (1:9)</span><br><span class="line">        at instantiate (/babel-lib/packages/babel-parser/lib/parse-error/credentials.js:27:32)</span><br><span class="line">        at constructor (/babel-lib/packages/babel-parser/lib/parse-error.js:41:41)</span><br><span class="line">        at Parser.raise (/babel-lib/packages/babel-parser/lib/tokenizer/index.js:1062:19)</span><br><span class="line">        at Parser.unexpected (/babel-lib/packages/babel-parser/lib/tokenizer/index.js:1095:16)</span><br><span class="line">        at Parser.parseIdentifierName (/babel-lib/packages/babel-parser/lib/parser/expression.js:1641:18)</span><br><span class="line">        at Parser.parseIdentifier (/babel-lib/packages/babel-parser/lib/parser/expression.js:1624:23)</span><br><span class="line">        at Parser.parseFunctionId (/babel-lib/packages/babel-parser/lib/parser/statement.js:991:79)</span><br><span class="line">        at Parser.parseFunction (/babel-lib/packages/babel-parser/lib/parser/statement.js:961:22)</span><br><span class="line">        at Parser.parseFunctionStatement (/babel-lib/packages/babel-parser/lib/parser/statement.js:603:17)</span><br><span class="line">        at Parser.parseStatementContent (/babel-lib/packages/babel-parser/lib/parser/statement.js:272:21) &#123;</span><br><span class="line">      code: <span class="string">'BABEL_PARSER_SYNTAX_ERROR'</span>,</span><br><span class="line">      reasonCode: <span class="string">'UnexpectedToken'</span>,</span><br><span class="line">      loc: Position &#123; line: 1, column: 9, index: 9 &#125;,</span><br><span class="line">      pos: [Getter/Setter]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>观察错误信息，发现关键错误点在 <code>parseIdentifierName</code> 里报 <code>unexpected</code> 错误，下面调试下逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/babel-parser/src/parser/expression.ts</span></span><br><span class="line"></span><br><span class="line"> parseIdentifierName(liberal?: boolean): string &#123;</span><br><span class="line">    <span class="keyword">let</span> name: string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; startLoc, type &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"identifier value"</span>, <span class="keyword">this</span>.state.value);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"next identifier value"</span>, <span class="keyword">this</span>.lookahead().value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokenIsKeywordOrIdentifier(type)) &#123;</span><br><span class="line">      name = <span class="keyword">this</span>.state.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">this</span>.unexpected();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以问题是 babel 不认识 @! 标识符，那么处理一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/babel-parser/src/tokenizer/types.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> tt = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    at: createToken(<span class="string">"@"</span>),</span><br><span class="line">    atEM: createToken(<span class="string">"@!"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/babel-parser/src/parser/statement.ts</span></span><br><span class="line"></span><br><span class="line"> parseFunction&lt;T extends N.NormalFunction&gt;(</span><br><span class="line">    <span class="keyword">this</span>: Parser,</span><br><span class="line">    node: Undone&lt;T&gt;,</span><br><span class="line">    statement: number = FUNC_NO_FLAGS,</span><br><span class="line">    isAsync: boolean = <span class="literal">false</span>,</span><br><span class="line">  ): T &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    node.generator = <span class="keyword">this</span>.eat(tt.star);</span><br><span class="line">    <span class="comment">// 实现自定义语法 @！</span></span><br><span class="line">    node.logThisFunc = <span class="keyword">this</span>.eat(tt.atEM);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再次执行 jest 成功:<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221209155741.png" alt="执行成功"></p><p>查看 ast 结果，logThisFunc 已标记：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221209155905.png" alt="查看 ast 结果"></p><p>// TODO 编写插件，实现转换逻辑</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用-babel-实现用-标记一个函数时，将为函数自动加上调用日志打印的功能&quot;&gt;&lt;a href=&quot;#用-babel-实现用-标记一个函数时，将为函数自动加上调用日志打印的功能&quot; class=&quot;headerlink&quot; title=&quot;用 babel 实现用 @!标记一个函数时，将为函数自动加上调用日志打印的功能&quot;&gt;&lt;/a&gt;用 babel 实现用 &lt;code&gt;@!&lt;/code&gt;标记一个函数时，将为函数自动加上调用日志打印的功能&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; @! &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 转化为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;function name:&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;date:&#39;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
      <category term="Babel" scheme="https://lilong7676.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>babel 的原理及插件的编写（简要）</title>
    <link href="https://lilong7676.github.io/2022/11/23/javascript/babel%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%88%E7%AE%80%E8%A6%81%EF%BC%89/"/>
    <id>https://lilong7676.github.io/2022/11/23/javascript/babel的原理及插件的编写（简要）/</id>
    <published>2022-11-23T02:39:06.000Z</published>
    <updated>2023-06-08T06:26:43.565Z</updated>
    
    <content type="html"><![CDATA[<!-- # 什么是 AST # 访问者模式# babel-parser# babel-traverse --><h3 id="由浅入深，先从几个简单的插件的编写开始吧"><a href="#由浅入深，先从几个简单的插件的编写开始吧" class="headerlink" title="由浅入深，先从几个简单的插件的编写开始吧"></a>由浅入深，先从几个简单的插件的编写开始吧</h3><p>（本次分析的 babel 版本为 7.20.4）</p><a id="more"></a><hr><blockquote><h4 id="实现一个自动将-console-log-信息加上所属代码的位置（行列）信息的-babel-插件"><a href="#实现一个自动将-console-log-信息加上所属代码的位置（行列）信息的-babel-插件" class="headerlink" title="实现一个自动将 console.log 信息加上所属代码的位置（行列）信息的 babel 插件"></a><em>实现一个自动将 console.log 信息加上所属代码的位置（行列）信息的 babel 插件</em></h4></blockquote><p>例子代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>, a);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ul><li>首先查看这段代码对应的<a href="https://astexplorer.net/#/gist/9357ea04e1cbba03852c2978bf5f4ecb/75b12e8e7c4e82217e17ba7ec6f9db1d7c555aae" target="_blank" rel="noopener"> AST 结构</a></li></ul><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221207111654.png" alt="AST 结构"></p><ul><li><p>在上图可以看到 <code>console.log</code> 对应的节点类型为 <code>CallExpression -&gt; MemberExpress -&gt; Identifier</code>，所以我们的思路是：</p><ul><li>找到类型为 CallExpression 的节点</li><li>判断其代码是否是 console.log</li><li>拿到位置信息</li><li>插入到 arguments 数组中</li></ul></li></ul><p>具体实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">"@babel/core"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testCode = <span class="string">`function test() &#123;</span></span><br><span class="line"><span class="string">  const a = 2;</span></span><br><span class="line"><span class="string">  console.log('a', a);</span></span><br><span class="line"><span class="string">  return a;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test();</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCustomPlugin</span>(<span class="params">&#123; types &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      CallExpression(path, state) &#123;</span><br><span class="line">        <span class="comment">// 判断 callee 是否是 console.log</span></span><br><span class="line">        <span class="keyword">const</span> callee = generate(path.node.callee).code;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"console.log"</span> === callee) &#123;</span><br><span class="line">          <span class="comment">// 拿到其代码位置信息</span></span><br><span class="line">          <span class="keyword">const</span> &#123; line, column &#125; = path.node.loc.start;</span><br><span class="line">          <span class="comment">// 将位置信息插入到 arguments 数组中</span></span><br><span class="line">          path.node.arguments.unshift(</span><br><span class="line">            types.stringLiteral(<span class="string">`loc:[<span class="subst">$&#123;line&#125;</span>,<span class="subst">$&#123;column&#125;</span>]`</span>)</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = babel.transformSync(testCode, &#123;</span><br><span class="line">  plugins: [myCustomPlugin],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output.code);</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221207114055.png" alt></p><br><hr><blockquote><h4 id="把代码里的-标识符n-转换为-标识符x"><a href="#把代码里的-标识符n-转换为-标识符x" class="headerlink" title="把代码里的 标识符n 转换为 标识符x"></a><em>把代码里的 标识符n 转换为 标识符x</em></h4></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的逻辑是把 代码里的 标识符n 转换为 标识符x</span></span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'../babel-lib/packages/babel-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'../babel-lib/packages/babel-traverse'</span>).default;</span><br><span class="line"><span class="keyword">const</span> generate = <span class="built_in">require</span>(<span class="string">'../babel-lib/packages/babel-generator'</span>).default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">'const n = 1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse the code -&gt; ast</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform the ast</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="comment">// 'n' to 'x'</span></span><br><span class="line">    <span class="keyword">if</span> (path.isIdentifier(&#123; <span class="attr">name</span>: <span class="string">'n'</span> &#125;)) &#123;</span><br><span class="line">      path.node.name = <span class="string">'x'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ast to code</span></span><br><span class="line"><span class="keyword">const</span> output = generate(ast);</span><br><span class="line"><span class="built_in">console</span>.log(output.code); <span class="comment">// 'const x = 1;'</span></span><br></pre></td></tr></table></figure><p>上面实现了一些简单的 babel 转换插件，实现思路也很清晰了，整体的思路就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code -&gt; AST -&gt; transformed AST -&gt; transformed code</span><br></pre></td></tr></table></figure><p>下面分析下其基本原理。</p><br><h3 id="首先简单介绍下什么是-AST"><a href="#首先简单介绍下什么是-AST" class="headerlink" title="首先简单介绍下什么是 AST"></a>首先简单介绍下什么是 AST</h3><p>AST(abstract syntax tree)，即抽象语法树。 </p><h4 id="关键的概念"><a href="#关键的概念" class="headerlink" title="关键的概念"></a>关键的概念</h4><ol><li>Tokenizer 分词： 将整个代码字符串分割成语法单元数组（token）</li></ol><p>JS 代码中的语法单元主要指如标识符（if/else、return、function）、运算符、括号、数字、字符串、空格等等能被解析的最小单。 <a href="https://esprima.org/demo/parse.html#" target="_blank" rel="noopener">可以看下这个在线分词工具</a>;</p><p>2.语法分析： 在分词结果的基础上分析语法单元之间的关系。</p><p>语义分析则是将得到的词汇进行一个立体的组合，确定词语之间的关系。</p><p>先理解两个重要概念，即语句和表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>语句(statement)，👆上面就是一条语句，一般情况下，在js里每一行就是一个语句。<br>表达式(expression)，如上面的 <code>1 + 2</code>就是表达式，是指最终有返回结果的一小段代码，可以嵌入到另一个表达式，且包含在语句中。<br>简单来说语法分析是对语句和表达式识别，这是个递归过程，在解析中，babel 会在解析每个语句和表达式的过程中设置一个暂存器，用来暂存当前读取到的语法单元，如果解析失败，就会返回之前的暂存点，再按照另一种方式进行解析，如果解析成功，则将暂存点销毁，不断重复以上操作，直到最后生成对应的语法树。</p><p>先看下编译原理中，词法分析到语法分析阶段图：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221207165755.png" alt="词法分析到语法分析"></p><p>上面的产物 parse tree 即解析树，代表了源码的所有信息，很详细，也很冗余（包含分号，冒号等），而 AST，抽象了一些，即精简了 parse tree：</p><p><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221207170423.png" alt></p><ul><li>AST不含有语法细节，比如冒号、括号、分号</li><li>AST会压缩单继承节点</li><li>操作符会变成内部节点，不再会以叶子节点出现在树的末端。</li></ul><h3 id="那-babel-怎么将代码转为-AST-的？"><a href="#那-babel-怎么将代码转为-AST-的？" class="headerlink" title="那 babel 怎么将代码转为 AST 的？"></a>那 babel 怎么将代码转为 AST 的？</h3><p>根据<a href="https://babeljs.io/docs/en/babel-parser#output" target="_blank" rel="noopener">文档</a>可知要在 <code>packages/babel-parser</code> 里找逻辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 babel 源码目录里执行</span></span><br><span class="line">$ make watch <span class="comment"># 编译并 watch</span></span><br><span class="line">$ <span class="built_in">cd</span> packages/babel-parse/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 在 babel-parse 里新建单元测试文件，用来验证逻辑</span></span><br><span class="line">$ touch <span class="built_in">test</span>-parser.js</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test-parser.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"../lib/index.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParser</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// sourceType 可能的值为 "script", "module", or "unambiguous"，</span></span><br><span class="line">  <span class="comment">// 如果是 unambiguous，则 babel 会尝试判断代码中是否包含 import export 语句来确定具体类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">"module"</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">"测试 parse -&gt; ast"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"should parse"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(getParser(<span class="string">`function foo() &#123;&#125;`</span>)()).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过下面的命令执行 jest</span></span><br><span class="line"> $ BABEL_ENV=<span class="built_in">test</span> node_modules/.bin/jest -u packages/babel-parser/<span class="built_in">test</span>/<span class="built_in">test</span>-parser.js</span><br></pre></td></tr></table></figure><p>查看 <code>parse</code> 函数源码，得到其执行路径：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221208144240.png" alt="parse()执行路径"></p><p>其中 Parser 类继承关系：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221208140115.png" alt="Parser 继承路径"></p><p>关注点转移到 <code>parser.parse()</code> 函数中，查看<a href="https://github.com/lilong7676/babel/blob/871fd5ec0c22829495d6a11b1729feb7e9e52ad7/packages/babel-parser/src/parser/index.ts#L39" target="_blank" rel="noopener">源码:</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">parse(): N.File &#123;</span><br><span class="line">  <span class="comment">// 进入到初始作用域中</span></span><br><span class="line">  <span class="keyword">this</span>.enterInitialScopes();</span><br><span class="line">  <span class="comment">// 初始化 file、program 节点</span></span><br><span class="line">  <span class="keyword">const</span> file = <span class="keyword">this</span>.startNode() <span class="keyword">as</span> N.File;</span><br><span class="line">  <span class="keyword">const</span> program = <span class="keyword">this</span>.startNode() <span class="keyword">as</span> N.Program;</span><br><span class="line">  <span class="comment">// 获取并更新下一个 token 信息</span></span><br><span class="line">  <span class="keyword">this</span>.nextToken();</span><br><span class="line">  file.errors = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 从头节点开始解析</span></span><br><span class="line">  <span class="keyword">this</span>.parseTopLevel(file, program);</span><br><span class="line">  file.errors = <span class="keyword">this</span>.state.errors;</span><br><span class="line">  <span class="comment">// 返回解析结果，即 ast</span></span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注点转移到 <code>this.nextToken()</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取并更新下一个 token 信息</span></span><br><span class="line">  nextToken(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略空白字符（空格、tab、换行等）并更新当前位置信息</span></span><br><span class="line">    <span class="keyword">this</span>.skipSpace();</span><br><span class="line">    <span class="comment">// 记录当前 token 开始字符位置</span></span><br><span class="line">    <span class="keyword">this</span>.state.start = <span class="keyword">this</span>.state.pos;</span><br><span class="line">    <span class="comment">// 如果不是 “临时向前看”，则记录 token 开始位置（行、列、index）</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isLookahead) <span class="keyword">this</span>.state.startLoc = <span class="keyword">this</span>.state.curPosition();</span><br><span class="line">    <span class="comment">// 如果当前 tokenizer 的位置已经到了 input 的末尾</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.pos &gt;= <span class="keyword">this</span>.length) &#123;</span><br><span class="line">      <span class="comment">// 则结束本次 token 查找，并更新当前 token 的信息（位置、token类型、token值）到 state 上</span></span><br><span class="line">      <span class="keyword">this</span>.finishToken(tt.eof);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前的 字符，读取相应的 token</span></span><br><span class="line">    <span class="keyword">this</span>.getTokenFromCode(<span class="keyword">this</span>.codePointAtPos(<span class="keyword">this</span>.state.pos));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>感兴趣的可以继续查看 <code>getTokenFromCode</code> 的实现逻辑，这里其实就是 tokenzier 的核心逻辑</p></blockquote><p>关注点转移到  <code>parseTopLevel() -&gt; parseProgram -&gt; parseBlockBody -&gt; parseBlockOrModuleBlockBody -&gt;  parseStatement -&gt; parseStatementContent</code><br>具体逻辑可以查看 <a href="https://github.com/lilong7676/babel/tree/main/packages/babel-parser/src" target="_blank" rel="noopener">github</a> 上添加的代码注释。</p><hr><h3 id="babel-是如何遍历-ast的？"><a href="#babel-是如何遍历-ast的？" class="headerlink" title="babel 是如何遍历 ast的？"></a>babel 是如何遍历 ast的？</h3><p>在 <code>packages/babel-traverse</code> 有两个关键的对象:</p><p><strong>Visitor</strong><br>对于这个遍历过程，babel 通过实例化 visitor 对象完成，其实我们生成出来的 AST 结构都拥有一个 accept 方法用来接收 visitor 访问者对象的访问，而访问者其中也定义了 visit 方法(即开发者定义的函数方法)使其能够对树状结构不同节点做出不同的处理，借此做到在对象结构的一次访问过程中，我们能够遍历整个对象结构。（访问者设计模式：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作）</p><p>遍历结点让我们可以定位并找到我们想要操作的结点，在遍历每一个节点时，存在enter和exit两个时态周期，一个是进入结点时，这个时候节点的子节点还没触达，遍历子节点完成的后，会离开该节点并触发exit方法。</p><p><strong>Path</strong><br>Visitors 在遍历到每个节点的时候，都会给我们传入 path 参数，包含了节点的信息以及节点和所在的位置，供我们对特定节点进行修改，之所以称之为 path 是其表示的是两个节点之间连接的对象，而非指当前的节点对象。path属性有几个重要的组成，主要如下：<br><img src="https://lilong7676-picture.oss-cn-hangzhou.aliyuncs.com/img/20221209142949.png" alt="Path"></p><p>关键路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// babel-traverse</span><br><span class="line">traverse(options) -&gt; traverseNode(...) -&gt; new TraversalContext() -&gt; context.visit(node, key)</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" target="_blank" rel="noopener">Leveling Up One’s Parsing Game With ASTs</a></p><h4 id="彩蛋：Babel-song"><a href="#彩蛋：Babel-song" class="headerlink" title="彩蛋：Babel song"></a>彩蛋：Babel song</h4><p>Hallelujah ——  <a href="https://youtu.be/40abpedBKK8" target="_blank" rel="noopener">In Praise of Babel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- # 什么是 AST 
# 访问者模式
# babel-parser
# babel-traverse --&gt;

&lt;h3 id=&quot;由浅入深，先从几个简单的插件的编写开始吧&quot;&gt;&lt;a href=&quot;#由浅入深，先从几个简单的插件的编写开始吧&quot; class=&quot;headerlink&quot; title=&quot;由浅入深，先从几个简单的插件的编写开始吧&quot;&gt;&lt;/a&gt;由浅入深，先从几个简单的插件的编写开始吧&lt;/h3&gt;&lt;p&gt;（本次分析的 babel 版本为 7.20.4）&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
      <category term="Babel" scheme="https://lilong7676.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>初步安装 knative</title>
    <link href="https://lilong7676.github.io/2022/09/08/Knative/%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85-Knative/"/>
    <id>https://lilong7676.github.io/2022/09/08/Knative/初步安装-Knative/</id>
    <published>2022-09-08T02:02:11.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://knative.dev/docs/getting-started/quickstart-install/#before-you-begin" target="_blank" rel="noopener">https://knative.dev/docs/getting-started/quickstart-install/#before-you-begin</a></p><p>注意，由于我在虚拟机里走了vpn代理，所以以下命令都没有使用国内源。</p><p>前提条件：</p><ol><li>安装了 minikube、kubectl，参考 <a href="https://lilong7676.github.io/2022/09/08/minikube/k8s/%E5%9C%A8-vmware-centos7-%E4%B8%AD%E6%8E%A2%E7%B4%A2-k8s-%E4%B8%8E-KNative/">在 vmware centos7 中安装 minikube</a>.</li></ol><a id="more"></a><h1 id="1-安装-Knative-CLI-（kn）-参考连接"><a href="#1-安装-Knative-CLI-（kn）-参考连接" class="headerlink" title="1. 安装 Knative CLI （kn）(参考连接)"></a>1. 安装 Knative CLI （kn）(<a href="https://knative.dev/docs/getting-started/quickstart-install/#install-the-knative-cli" target="_blank" rel="noopener">参考连接</a>)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">$ curl -fsSL https://github.com/knative/client/releases/download/knative-v1.7.0/kn-linux-amd64 -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名二进制包名为 kn</span></span><br><span class="line">$ mv kn-linux-amd64 kn</span><br><span class="line">$ chmod +x kn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动 kn 到 bin 目录</span></span><br><span class="line">$ sudo mv kn /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line"></span><br><span class="line">$ kn version</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220914105352.png" alt="kn version"></p><h1 id="2-安装-Knative-quickstart-插件-参考链接"><a href="#2-安装-Knative-quickstart-插件-参考链接" class="headerlink" title="2. 安装 Knative quickstart 插件 (参考链接)"></a>2. 安装 Knative quickstart 插件 (<a href="https://knative.dev/docs/getting-started/quickstart-install/#install-the-knative-quickstart-plugin" target="_blank" rel="noopener">参考链接</a>)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 kn-quickstart-linux-amd64 二进制文件</span></span><br><span class="line">$ curl -fsSL https://github.com/knative-sandbox/kn-plugin-quickstart/releases/download/knative-v1.7.1/kn-quickstart-linux-amd64 -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名为 kn-quickstart</span></span><br><span class="line">$ mv kn-quickstart-linux-amd64 kn-quickstart</span><br><span class="line">$ chmod +x kn-quickstart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动 kn-quickstart 到 bin 目录</span></span><br><span class="line">$ sudo mv kn-quickstart /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否安装成功</span></span><br><span class="line">$ kn quickstart --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220914110252.png" alt="kn quickstart --help"></p><h1 id="3-运行-Knative-quickstart-插件-（参考）"><a href="#3-运行-Knative-quickstart-插件-（参考）" class="headerlink" title="3.运行 Knative quickstart 插件 （参考）"></a>3.运行 Knative quickstart 插件 （<a href="https://knative.dev/docs/getting-started/quickstart-install/#run-the-knative-quickstart-plugin" target="_blank" rel="noopener">参考</a>）</h1><p><code>quickstart</code> 插件会完成以下功能：  </p><ol><li>检查你是否已经安装了所选的 k8s 实例</li><li>创建一个集群，名字为 <code>knative</code></li><li>安装 Knative Serving，使用 <code>Kourier</code> 作为默认的网络层，<code>sslip.io</code>作为 DNS</li><li>安装 Knative Eventing，并且创建一个 in-memory Broker 和 Channel 的实现</li></ol><p>为了在本地部署 Knative，需要运行 <code>quickstart</code> 插件:<br>由于本地已经安装了 <code>minikube</code>，所以这里以 <code>minikube</code> 启动插件：  </p><ol><li>在 <code>minikube</code> 实例中安装 Knative 和 k8s:<blockquote><p>注意：minikube 集群将使用 6GB 内存创建。如果没有足够的内存，则可以在该命令之前运行命令 <code>minikube config set memory 3078</code>，将其更改为不低于 <code>3 GB</code> 的其他值。</p></blockquote></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kn quickstart minikube</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220914145319.png" alt="kn quickstart minikube"></p><ol start="2"><li>根据上一步中的提示，新开一个 terminal 窗口，执行:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ minikube tunnel --profile knative</span><br></pre></td></tr></table></figure></li></ol><p>在使用 Knative <code>quickstart</code> 环境时，终端里必须运行此 <code>tunnel</code></p><ol start="3"><li><p>回到上一个窗口，按 <code>Enter</code> 键继续安装</p></li><li><p>验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube profile list</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220914145849.png" alt="minikube profile list"></p><h1 id="4-部署一个-Knative-Service-参考"><a href="#4-部署一个-Knative-Service-参考" class="headerlink" title="4. 部署一个 Knative Service (参考)"></a>4. 部署一个 Knative Service (<a href="https://knative.dev/docs/getting-started/first-service/#deploying-a-knative-service" target="_blank" rel="noopener">参考</a>)</h1><p>有两种方式部署，可选 <code>kn</code> 命令部署 或者编写 YAML 配置文件并使用 <code>kubectl apply</code> 部署，具体可参考官网。</p><ol><li>使用 <code>kn</code> 部署<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kn service create hello \</span><br><span class="line">--image gcr.io/knative-samples/helloworld-go \</span><br><span class="line">--port 8080 \</span><br><span class="line">--env TARGET=World</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://knative.dev/docs/getting-started/quickstart-install/#before-you-begin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://knative.dev/docs/getting-started/quickstart-install/#before-you-begin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意，由于我在虚拟机里走了vpn代理，所以以下命令都没有使用国内源。&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装了 minikube、kubectl，参考 &lt;a href=&quot;https://lilong7676.github.io/2022/09/08/minikube/k8s/%E5%9C%A8-vmware-centos7-%E4%B8%AD%E6%8E%A2%E7%B4%A2-k8s-%E4%B8%8E-KNative/&quot;&gt;在 vmware centos7 中安装 minikube&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Knative" scheme="https://lilong7676.github.io/categories/Knative/"/>
    
    
  </entry>
  
  <entry>
    <title>在 vmware centos7 中安装与探索 k8s</title>
    <link href="https://lilong7676.github.io/2022/09/08/minikube/k8s/%E5%9C%A8-vmware-centos7-%E4%B8%AD%E5%AE%89%E8%A3%85%E4%B8%8E%E6%8E%A2%E7%B4%A2-k8s/"/>
    <id>https://lilong7676.github.io/2022/09/08/minikube/k8s/在-vmware-centos7-中安装与探索-k8s/</id>
    <published>2022-09-08T02:02:11.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">https://minikube.sigs.k8s.io/docs/start/</a><br><a href="https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script</a><br><a href="https://www.cnblogs.com/yyee/p/15071684.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyee/p/15071684.html</a></p><p>注意，由于我在虚拟机里走了vpn代理，所以以下命令都没有使用国内源。</p><a id="more"></a><h3 id="使用-SSH-连接-VMware-上的-CentOS-虚拟机（可选）"><a href="#使用-SSH-连接-VMware-上的-CentOS-虚拟机（可选）" class="headerlink" title="使用 SSH 连接 VMware 上的 CentOS 虚拟机（可选）"></a>使用 SSH 连接 VMware 上的 CentOS 虚拟机（可选）</h3><ul><li><p>安装 openssh-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>启用22端口监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 取消下面两行的注释</span></span><br><span class="line"><span class="comment"># Port 22</span></span><br><span class="line"><span class="comment"># ListenAddress 0.0.0.0</span></span><br></pre></td></tr></table></figure></li><li><p>开启 sshd 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service sshd start</span><br></pre></td></tr></table></figure></li><li><p>检测 22 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep 22</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220908143016.png" alt="检测 22 端口"></p></li><li><p>主机与虚拟机进行互相ping，如果ping通了，表示主机和虚拟机在同一个子网，则直接 <code>ssh root@ip</code> 即可。</p></li><li><p>如果没有ping通，则表示主机和虚拟机没有在一个字网，需要修改网络配置，可参考<a href="https://www.jianshu.com/p/f38133c1485a" target="_blank" rel="noopener">这里</a>进行配置。</p></li></ul><h3 id="安装-docker-和-minikube"><a href="#安装-docker-和-minikube" class="headerlink" title="安装 docker 和 minikube"></a>安装 docker 和 minikube</h3><ul><li><p>安装 docker engine</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script</span></span><br><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br></pre></td></tr></table></figure></li><li><p>启动 docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>Add your user to the ‘docker’ group</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span> &amp;&amp; newgrp docker</span><br></pre></td></tr></table></figure></li><li><p>安装 minikube</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内最好走代理访问，参考自 https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/#macos-and-linux</span></span><br><span class="line"><span class="comment"># export HTTP_PROXY="http://yourip:port" </span></span><br><span class="line"><span class="comment"># export HTTPS_PROXY="http://yourip:port"</span></span><br><span class="line"><span class="comment"># export NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://minikube.sigs.k8s.io/docs/start/</span></span><br><span class="line">$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line">$ sudo install minikube-linux-amd64 /usr/<span class="built_in">local</span>/bin/minikube</span><br></pre></td></tr></table></figure></li><li><p><a href="https://minikube.sigs.k8s.io/docs/drivers/docker/#requirements" target="_blank" rel="noopener">配置 minikube(可选)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start a cluster using the docker driver:</span></span><br><span class="line">minikube start --driver=docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># To make docker the default driver:</span></span><br><span class="line">minikube config <span class="built_in">set</span> driver docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动-minikube"><a href="#启动-minikube" class="headerlink" title="启动 minikube"></a>启动 minikube</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果已经走代理了，则直接执行</span></span><br><span class="line">$ minikube start </span><br><span class="line"><span class="comment"># 否则国内环境最好使用镜像源</span></span><br><span class="line">$ minikube start --image-mirror-country cn \</span><br><span class="line">--image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"><span class="comment"># 如果出现下面提示，解决方案参考： https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user</span></span><br><span class="line"><span class="comment">#❌  Exiting due to DRV_AS_ROOT: The "docker" driver should not be used with root privileges.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 `minikube start`后，会下载安装 k8s等依赖，耐心等待</span></span><br></pre></td></tr></table></figure><p>  此时执行 <code>$ docker ps</code>会发现 minikube 其实就是docker中运行的容器。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  $ docker ps</span><br><span class="line">  CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                                                                  NAMES</span><br><span class="line">c07efbc6d848   kicbase/stable:v0.0.33   <span class="string">"/usr/local/bin/entr…"</span>   14 minutes ago   Up 14 minutes   127.0.0.1:49162-&gt;22/tcp, 127.0.0.1:49161-&gt;2376/tcp, 127.0.0.1:49160-&gt;5000/tcp, 127.0.0.1:49159-&gt;8443/tcp, 127.0.0.1:49158-&gt;32443/tcp   minikube</span><br></pre></td></tr></table></figure></p><h3 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h3><ul><li>可参考这里： <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO <span class="string">"https://dl.k8s.io/release/<span class="variable">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl"</span></span><br><span class="line"></span><br><span class="line">$ sudo install -o root -g root -m 0755 kubectl /usr/<span class="built_in">local</span>/bin/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本验证安装是否成功</span></span><br><span class="line">$ kubectl version --client</span><br></pre></td></tr></table></figure><h1 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h1><ul><li><p>使用 <code>kubectl</code> 查看当前集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -A</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220909113846.png" alt="使用 kubectl 查看当前集群"></p></li><li><p>minikube 集成了 k8s Dashboard,可以在浏览器中查看当前集群情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ minikube dashboard</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220909114717.png" alt="minikube dashboard"></p><p>暴露端口给外部访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl proxy --address=<span class="string">'0.0.0.0'</span> --<span class="built_in">disable</span>-filter=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220909120236.png" alt="暴露端口给外部访问"></p><p>发现暴露了8001端口给外部访问，但是此时在宿主机无法打开 <code>http://centos_ip:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</code> ,因为防火墙的配置不允许，所以👇下面是配置防火墙的步骤。</p></li><li><p>配置 centos 防火墙以暴露指定端口给宿主机访问（<a href="https://www.cnblogs.com/yyee/p/15071684.html" target="_blank" rel="noopener">参考自这里</a>）</p><p>因为我是本地用的虚拟机安装的 centos7，所以上面的 dashboard 页面无法直接在宿主机内打开，所以参考这里修改centos 防火墙即可</p><p>首先前提是我的虚拟机网络走的是 NAT转发模式，以下为在虚拟机内操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置防火墙允许NAT转发</span></span><br><span class="line">$ sudo firewall-cmd --zone=public --add-masquerade --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 ifconfig 命令查看 127.0.0.1 属于哪个网卡，我这里网卡的名字是 lo</span></span><br><span class="line"><span class="comment"># 下面把 lo 网卡添加到 trusted 域</span></span><br><span class="line">$ sudo firewall-cmd --permanent --zone=trusted --change-interface=lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS: 我这里顺便把 docker0 网卡也添加到信任域了，方便以后访问docker内的端口</span></span><br><span class="line"><span class="comment"># sudo firewall-cmd --permanent --zone=trusted --change-interface=docker0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 8001 端口（minikube dashboard proxy 默认为 8001 端口）</span></span><br><span class="line">$ sudo firewall-cmd --add-port=8001/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启防火墙即可</span></span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>此时在宿主机即可访问虚拟机8001端口： <code>http://vm_ip:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/workloads?namespace=default</code></p></li></ul><h1 id="部署一个应用试试"><a href="#部署一个应用试试" class="headerlink" title="部署一个应用试试"></a>部署一个应用试试</h1><p>这里可以参考官网的教程（<a href="https://minikube.sigs.k8s.io/docs/start/），官网部署的是:`k8s.gcr.io/echoserver:1.4`,但是一直显示pull" target="_blank" rel="noopener">https://minikube.sigs.k8s.io/docs/start/），官网部署的是:`k8s.gcr.io/echoserver:1.4`,但是一直显示pull</a> image 失败，应该是镜像地址访问问题，所以这了换成了另一个demo镜像，你可以换成任何docker镜像。</p><ul><li><p>根据 demo 镜像创建一个 deployment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create deployment wordpress --image=wordpress</span><br></pre></td></tr></table></figure></li><li><p>暴露 NodePort 端口到 80，注意，这里的端口必须与docker镜像暴露的端口一致，否则无法访问到镜像内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment wordpress --<span class="built_in">type</span>=NodePort --port=80</span><br></pre></td></tr></table></figure></li><li><p>显示访问地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不加 --url，则会自动在浏览器中打开</span></span><br><span class="line">$ minikube services wordpress --url</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220909160506.png" alt="显示访问地址"></p></li><li><p>一些常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示 services 列表</span></span><br><span class="line">$ kubectl get services <span class="comment">#可简写为 kubectl get svc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前 deployment 列表</span></span><br><span class="line">$ kubectl get deployment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个 deployment</span></span><br><span class="line">$ kubectl delete deployment <span class="variable">$deploymentname</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个 service</span></span><br><span class="line">$ kubectl delete <span class="variable">$servicename</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol><li>minikube services wordpress 在浏览器中打不开这个地址<br>解决方式：结果发现是 terminal 使用了代理，重新打开一个 terminal 再执行命令就可以了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://minikube.sigs.k8s.io/docs/start/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://minikube.sigs.k8s.io/docs/start/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/yyee/p/15071684.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yyee/p/15071684.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意，由于我在虚拟机里走了vpn代理，所以以下命令都没有使用国内源。&lt;/p&gt;
    
    </summary>
    
      <category term="minikube" scheme="https://lilong7676.github.io/categories/minikube/"/>
    
      <category term="k8s" scheme="https://lilong7676.github.io/categories/minikube/k8s/"/>
    
    
  </entry>
  
  <entry>
    <title>flutter中通过ffi使用quickjs</title>
    <link href="https://lilong7676.github.io/2022/09/01/flutter/flutter%E4%B8%AD%E9%80%9A%E8%BF%87ffi%E4%BD%BF%E7%94%A8quickjs/"/>
    <id>https://lilong7676.github.io/2022/09/01/flutter/flutter中通过ffi使用quickjs/</id>
    <published>2022-09-01T02:43:43.000Z</published>
    <updated>2023-06-08T06:26:43.565Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>quickjs中 判断 JSValue 的类型</p><p>  在 <code>quickjs.h</code> 中 搜索 <code>JS_Is</code>开头的方法:</p><ul><li>JS_IsBool(JSValue)</li><li>JS_IsNull</li><li>JS_IsUndefined</li><li>JS_IsNumber</li><li>JS_IsString</li><li>JS_IsObject</li><li>JS_IsException</li><li>…</li><li><a id="more"></a></li></ul></li><li><p>quickjs中的 JSValue 与 c 类型的转换</p><p>   在<code>quickjs.h</code>中搜索 <code>JS_To</code>开头的方法：</p><ul><li>JS_ToBool(JSContext, JSValue)</li><li>JS_ToInt32</li><li>JS_ToInt64</li><li>JS_ToFloat64</li><li>JS_ToCString    需注意 JS_FreeCString</li></ul></li></ul><p>为什么 <code>webf</code> 中的 <code>NativeString</code> 类型，使用 uint16_t* 表示 string?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NativeString</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span>* <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">  <span class="function">NativeString* <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 首先， uint16_t 即为 unsigned short int 类型，值范围为 0 - 65535。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><ul><li>有关 JSString、JSAtom 的分析：<ul><li><a href="https://blog.csdn.net/jayyuz/article/details/124450556" target="_blank" rel="noopener">https://blog.csdn.net/jayyuz/article/details/124450556</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;quickjs中 判断 JSValue 的类型&lt;/p&gt;
&lt;p&gt;  在 &lt;code&gt;quickjs.h&lt;/code&gt; 中 搜索 &lt;code&gt;JS_Is&lt;/code&gt;开头的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS_IsBool(JSValue)&lt;/li&gt;
&lt;li&gt;JS_IsNull&lt;/li&gt;
&lt;li&gt;JS_IsUndefined&lt;/li&gt;
&lt;li&gt;JS_IsNumber&lt;/li&gt;
&lt;li&gt;JS_IsString&lt;/li&gt;
&lt;li&gt;JS_IsObject&lt;/li&gt;
&lt;li&gt;JS_IsException&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="flutter" scheme="https://lilong7676.github.io/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>web前端Proxy沙箱实现时需注意RegExp等原生对象问题</title>
    <link href="https://lilong7676.github.io/2022/08/31/javascript/web%E5%89%8D%E7%AB%AFProxy%E6%B2%99%E7%AE%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%9C%80%E6%B3%A8%E6%84%8FRegExp%E7%AD%89%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98/"/>
    <id>https://lilong7676.github.io/2022/08/31/javascript/web前端Proxy沙箱实现时需注意RegExp等原生对象问题/</id>
    <published>2022-08-31T06:52:01.000Z</published>
    <updated>2023-06-08T06:26:43.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>起因是一个前端js沙箱的实现中，发现通过沙箱执行代码中访问 RegExp.$n 的值一直是空字符串，类似于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">    const r = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/</span></span><br><span class="line"><span class="string">    r.exec('2022-08-31')</span></span><br><span class="line"><span class="string">    return RegExp.$1;`</span>;</span><br><span class="line">evalScriptInSandbox(code);</span><br></pre></td></tr></table></figure><a id="more"></a><p>正常情况下，<code>evalScriptInSandbox(code)</code> 应该返回 <code>&#39;2022&#39;</code>,但是执行发现只会返回空字符串，最后发现是 RegExp 的执行上下文问题。</p><p>因为沙箱的实现类似于这种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evalScriptSandbox = <span class="function">(<span class="params">code, fakeWindow</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> resolver = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    return function(window) &#123;</span></span><br><span class="line"><span class="string">      with(window) &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          return (function() &#123;</span></span><br><span class="line"><span class="string">            "use strict";</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">          &#125;)();</span></span><br><span class="line"><span class="string">        &#125; catch(e) &#123;</span></span><br><span class="line"><span class="string">          console.log(e);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正是这里的 call(fakeWindow)导致 RegExp 执行时的上下文是 fakeWindow </span></span><br><span class="line">  <span class="comment">// 而不是真正的宿主 window,导致 bug 产生</span></span><br><span class="line">  <span class="keyword">return</span> resolver().call(fakeWindow, fakeWindow);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解决方式就是访问<code>fakeWindow</code>中的 <code>RegExp</code> 对象时，需要返回宿主环境的 <code>RegExp</code>，这和浏览器的内部实现有关系，暂时没发现其他的解决方式。</p><h2 id="Reproduce-Step"><a href="#Reproduce-Step" class="headerlink" title="Reproduce Step :"></a>Reproduce Step :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/lilong7676/js-regexp-bug.git</span><br><span class="line">$ <span class="built_in">cd</span> js-regexp-bug</span><br><span class="line">$ npm i</span><br><span class="line">$ npm run start</span><br></pre></td></tr></table></figure><h2 id="⚠️"><a href="#⚠️" class="headerlink" title="⚠️"></a>⚠️</h2><p>⚠️另外需要注意，在 eval、Function 构造函数中执行正则表达式时，需要转义反斜线，即:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">`</span></span><br><span class="line"><span class="string">const r = /^(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)$/</span></span><br><span class="line"><span class="string">r.exec('2022-08-31'); // null</span></span><br><span class="line"><span class="string">console.log(RegExp.$1) // ''</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><p>在 eval 中需要写为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">`</span></span><br><span class="line"><span class="string">const r = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/</span></span><br><span class="line"><span class="string">r.exec('2022-08-31');</span></span><br><span class="line"><span class="string">console.log(RegExp.$1); // 2022</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><h3 id="类似的原生对象，如-eval-等，也会在这种沙箱的实现方式中出现作用域问题，需要注意。"><a href="#类似的原生对象，如-eval-等，也会在这种沙箱的实现方式中出现作用域问题，需要注意。" class="headerlink" title="类似的原生对象，如 eval 等，也会在这种沙箱的实现方式中出现作用域问题，需要注意。"></a>类似的原生对象，如 eval 等，也会在这种沙箱的实现方式中出现作用域问题，需要注意。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题起因&quot;&gt;&lt;a href=&quot;#问题起因&quot; class=&quot;headerlink&quot; title=&quot;问题起因&quot;&gt;&lt;/a&gt;问题起因&lt;/h2&gt;&lt;p&gt;起因是一个前端js沙箱的实现中，发现通过沙箱执行代码中访问 RegExp.$n 的值一直是空字符串，类似于：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; code = &lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    const r = /^(\\d&amp;#123;4&amp;#125;)-(\\d&amp;#123;1,2&amp;#125;)-(\\d&amp;#123;1,2&amp;#125;)$/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    r.exec(&#39;2022-08-31&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    return RegExp.$1;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;evalScriptInSandbox(code);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>记 RegExp 字面量形式在 eval 及 new Function里的行为异常问题</title>
    <link href="https://lilong7676.github.io/2022/08/29/uncategorized/%E8%AE%B0RegExp-%E5%9C%A8Eval%E5%8F%8Anew-Function%E9%87%8C%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://lilong7676.github.io/2022/08/29/uncategorized/记RegExp-在Eval及new-Function里的行为异常问题/</id>
    <published>2022-08-29T01:31:43.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一下最简单的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r = <span class="regexp">/^(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)$/</span>;</span><br><span class="line">r.exec(<span class="string">'2019-10-08'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// 2019</span></span><br></pre></td></tr></table></figure><p>上面这段代码在 Chrome console 中执行结果为 2019，一切正常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">`</span></span><br><span class="line"><span class="string">const r = /^(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)$/;</span></span><br><span class="line"><span class="string">r.exec('2019-10-08');</span></span><br><span class="line"><span class="string">RegExp.$1;</span></span><br><span class="line"><span class="string">`</span>); <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p><code>重新打开一个 Chrome console</code>, 然后执行上面这段代码，结果为<code>空字符串</code>，经过查阅资料，发现在 eval 中执行 regx的字面量时，需要<code>额外转义</code>反斜线，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">`</span></span><br><span class="line"><span class="string">const r = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;</span></span><br><span class="line"><span class="string">r.exec('2019-10-08');</span></span><br><span class="line"><span class="string">RegExp.$1;</span></span><br><span class="line"><span class="string">`</span>); <span class="comment">// '2019'</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/a/61147060/11394539" target="_blank" rel="noopener">https://stackoverflow.com/a/61147060/11394539</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先看一下最简单的代码&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; r = &lt;span class=&quot;regexp&quot;&gt;/^(\d&amp;#123;4&amp;#125;)-(\d&amp;#123;1,2&amp;#125;)-(\d&amp;#123;1,2&amp;#125;)$/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r.exec(&lt;span class=&quot;string&quot;&gt;&#39;2019-10-08&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;.$&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 2019&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面这段代码在 Chrome console 中执行结果为 2019，一切正常。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;const r = /^(\d&amp;#123;4&amp;#125;)-(\d&amp;#123;1,2&amp;#125;)-(\d&amp;#123;1,2&amp;#125;)$/;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;r.exec(&#39;2019-10-08&#39;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;RegExp.$1;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// &#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;重新打开一个 Chrome console&lt;/code&gt;, 然后执行上面这段代码，结果为&lt;code&gt;空字符串&lt;/code&gt;，
经过查阅资料，发现在 eval 中执行 regx的字面量时，需要&lt;code&gt;额外转义&lt;/code&gt;反斜线，即：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;const r = /^(\\d&amp;#123;4&amp;#125;)-(\\d&amp;#123;1,2&amp;#125;)-(\\d&amp;#123;1,2&amp;#125;)$/;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;r.exec(&#39;2019-10-08&#39;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;RegExp.$1;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// &#39;2019&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的 WebAssembly 编译流程 demo</title>
    <link href="https://lilong7676.github.io/2022/08/25/WebAssembly/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84WebAssembly%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8Bdemo/"/>
    <id>https://lilong7676.github.io/2022/08/25/WebAssembly/一个简单的WebAssembly编译流程demo/</id>
    <published>2022-08-25T08:09:19.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<p>记录下如何讲一个简单的程序编译为 wasm。由于我是mac环境，所以以下以mac环境为主，其他环境请参考 <a href="https://github.com/emscripten-core/emsdk" target="_blank" rel="noopener">官方github</a>。</p><a id="more"></a><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件:"></a>前置条件:</h2><p>git、cmake、Xcode(主要是llvm, linux为GCC)、Python 2.7.x</p><h2 id="编译-emsdk"><a href="#编译-emsdk" class="headerlink" title="编译 emsdk:"></a>编译 emsdk:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/juj/emsdk.git</span><br><span class="line">$ <span class="built_in">cd</span> emsdk</span><br><span class="line">$ ./emsdk install latest</span><br><span class="line">$ ./emsdk activate latest</span><br></pre></td></tr></table></figure><p>如果希望将 emsdk 加入到终端的环境变量里，则执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> <span class="string">"&#123;path_to_emsdk&#125;/emsdk_env.sh"</span></span><br></pre></td></tr></table></figure><h2 id="编译一个demo试试吧："><a href="#编译一个demo试试吧：" class="headerlink" title="编译一个demo试试吧："></a>编译一个demo试试吧：</h2><ol><li><p>新建一个 hello.c，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ emcc hello.c -s WASM=1 -o hello.html</span><br></pre></td></tr></table></figure></li></ol><p>注意 *-s WASM=1 * 参数，不加这个话，会编译为asm.js。</p><p>如果想要生成一个模板 html 页面，则输出文件的格式需为 html，即 * -o hello.html *。</p><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220825180332.png" alt="生成的文件"></p><ol start="3"><li>我们可以使用 emrun 命令来创建一个 http 协议的 web server 来展示我们编译后的文件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ emrun --no_browser --port 8080 .</span><br></pre></td></tr></table></figure><ol start="4"><li>在浏览器打开 <a href="http://0.0.0.0:8080/hello.html：" target="_blank" rel="noopener">http://0.0.0.0:8080/hello.html：</a><br><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220825180019.png" alt="效果图"></li></ol><h2 id="尝试加入一个第三方库进行编译"><a href="#尝试加入一个第三方库进行编译" class="headerlink" title="尝试加入一个第三方库进行编译"></a>尝试加入一个第三方库进行编译</h2><p>这里我选择将 <a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">cJSON</a> 这个库编译为 wasm:</p><ol><li><p>从 github 下载 cJSOM 源码到项目的 vendor 文件夹</p></li><li><p>新建 main.c，内容为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cJSON/cJSON.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> jsonstr[] = <span class="string">"&#123;\"data\":\"Hello World!!!\"&#125;"</span>;</span><br><span class="line">    cJSON *json = cJSON_Parse(jsonstr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cJSON *data = cJSON_GetObjectItem(json, <span class="string">"data"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, cJSON_GetStringValue(data));</span><br><span class="line"></span><br><span class="line">    cJSON_Delete(json);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建 CMakeLists.txt:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>) <span class="comment"># 根据你的需求进行修改</span></span><br><span class="line"><span class="keyword">project</span>(sample C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>) <span class="comment"># 根据你的C编译器支持情况进行修改</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXECUTABLE_SUFFIX <span class="string">".html"</span>) <span class="comment"># 编译生成.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(vendor) <span class="comment"># 使得我们能引用第三方库的头文件</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(vendor/cJSON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(sample main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Emscripten的编译链接参数，我们等等会讲到一些常用参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(sample PROPERTIES LINK_FLAGS <span class="string">"-s EXIT_RUNTIME=1"</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sample cjson) <span class="comment"># 将第三方库与主程序进行链接</span></span><br></pre></td></tr></table></figure></li><li><p>新建 build 文件夹，并执行编译操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ emcmake cmake ..</span><br><span class="line">$ emmake make</span><br></pre></td></tr></table></figure></li><li><p>此时会发现控制台报类似于下面的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  6%] Linking C executable sample.html</span><br><span class="line">wasm-ld: error: vendor/cJSON/libcjson.a(cJSON.c.o): undefined symbol: __stack_chk_guard</span><br></pre></td></tr></table></figure></li><li><p>解决上述错误的办法是修改 cJSON 的 CMakeLists.txt 中的 -fstack-protector-strong 修改为 -fno-stack-protector，然后重复步骤4</p></li><li><p>此时 build 文件夹内已生成 wasm：<br><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/20220826140809.png" alt="生成的wasm"></p></li><li><p>执行以下命令后，在浏览器 localhost:8080/sample.html 查看即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emrun --no_browser --port 8080 .</span><br></pre></td></tr></table></figure></li></ol><h2 id="后续再尝试将-flutter-jsdom-的-bridge-层打包为-wasm，需要先好好消化下😂"><a href="#后续再尝试将-flutter-jsdom-的-bridge-层打包为-wasm，需要先好好消化下😂" class="headerlink" title="后续再尝试将 flutter-jsdom 的 bridge 层打包为 wasm，需要先好好消化下😂"></a>后续再尝试将 <a href="https://github.com/lilong7676/flutter-jsdom" target="_blank" rel="noopener">flutter-jsdom</a> 的 bridge 层打包为 wasm，需要先好好消化下😂</h2><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol><li><p><a href="https://cloud.tencent.com/developer/news/690454" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/690454</a></p></li><li><p><a href="http://webassembly.org.cn/getting-started/developers-guide/" target="_blank" rel="noopener">http://webassembly.org.cn/getting-started/developers-guide/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下如何讲一个简单的程序编译为 wasm。由于我是mac环境，所以以下以mac环境为主，其他环境请参考 &lt;a href=&quot;https://github.com/emscripten-core/emsdk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方github&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="WebAssembly" scheme="https://lilong7676.github.io/categories/WebAssembly/"/>
    
    
      <category term="WebAssembly" scheme="https://lilong7676.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>参考iOS开发中的 UINavigationController 的思想，实现一个 React NavigationController</title>
    <link href="https://lilong7676.github.io/2022/08/25/uncategorized/%E5%8F%82%E8%80%83iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84-UINavigationController-%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-React-NavigationController/"/>
    <id>https://lilong7676.github.io/2022/08/25/uncategorized/参考iOS开发中的-UINavigationController-的思想，实现一个-React-NavigationController/</id>
    <published>2022-08-25T07:33:09.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考iOS开发中的-UINavigationController-的思想，实现了在React项目中的类似-iOS-页面转场的效果。"><a href="#参考iOS开发中的-UINavigationController-的思想，实现了在React项目中的类似-iOS-页面转场的效果。" class="headerlink" title="参考iOS开发中的 UINavigationController 的思想，实现了在React项目中的类似 iOS 页面转场的效果。"></a>参考iOS开发中的 UINavigationController 的思想，实现了在React项目中的类似 iOS 页面转场的效果。</h4><p>github：<a href="https://github.com/lilong7676/simple-chat/tree/main/packages/navigation-controller" target="_blank" rel="noopener">navigation-controller</a></p><ul><li>使用方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @lilong767676/navigation-controller</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavigationController &#125; <span class="keyword">from</span> <span class="string">'@lilong767676/navigation-controller'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先创建路由</span></span><br><span class="line"><span class="comment">// 路由名 - 页面 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> routes = &#123;</span><br><span class="line">  root: App,</span><br><span class="line">  [RouteNames.addFriendPage]: AddFriendsPage,</span><br><span class="line">  [RouteNames.newFriendsPage]: NewFriendsPage,</span><br><span class="line">  [RouteNames.chatHome]: ChatHome,</span><br><span class="line">  [RouteNames.chatPage]: ChatPage,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 NavigationController,单例模式，保证全局唯一</span></span><br><span class="line"><span class="keyword">const</span> naviController = <span class="keyword">new</span> NavigationController(routes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 rootContainer</span></span><br><span class="line">naviController.setRootContainer(ele);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面跳转</span></span><br><span class="line">NavigationController.push(RouteNames.addFriendPage, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回上一页面</span></span><br><span class="line">NavigationController.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁 NavigationController</span></span><br><span class="line">naviController.destroy();</span><br></pre></td></tr></table></figure><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p><img src="https://raw.githubusercontent.com/lilong7676/Picture/master/blog/image/2022-08-17%2014.56.19.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;参考iOS开发中的-UINavigationController-的思想，实现了在React项目中的类似-iOS-页面转场的效果。&quot;&gt;&lt;a href=&quot;#参考iOS开发中的-UINavigationController-的思想，实现了在React项目中的类似-iOS-页面转场的效果。&quot; class=&quot;headerlink&quot; title=&quot;参考iOS开发中的 UINavigationController 的思想，实现了在React项目中的类似 iOS 页面转场的效果。&quot;&gt;&lt;/a&gt;参考iOS开发中的 UINavigationController 的思想，实现了在React项目中的类似 iOS 页面转场的效果。&lt;/h4&gt;&lt;p&gt;github：&lt;a href=&quot;https://github.com/lilong7676/simple-chat/tree/main/packages/navigation-controller&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;navigation-controller&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用方式&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install @lilong767676/navigation-controller&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的web IM程序</title>
    <link href="https://lilong7676.github.io/2022/08/25/web/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web-IM%E7%A8%8B%E5%BA%8F/"/>
    <id>https://lilong7676.github.io/2022/08/25/web/一个简单的web-IM程序/</id>
    <published>2022-08-25T07:24:03.000Z</published>
    <updated>2023-06-08T06:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要技术栈"><a href="#主要技术栈" class="headerlink" title="主要技术栈"></a>主要技术栈</h3><ul><li>React</li><li>Indexeddb(Dexie)</li><li>Socket.io</li><li>Nodejs + Express + typeorm + Mysql + Redis</li><li>Pnpm monorepo</li><li>Docker compose + Github Actions CI</li></ul><p>实现细节请查看github仓库: <a href="https://github.com/lilong7676/simple-chat" target="_blank" rel="noopener">simple-chat</a></p><a id="more"></a><h3 id="目前主要功能"><a href="#目前主要功能" class="headerlink" title="目前主要功能:"></a>目前主要功能:</h3><ul><li>user register &amp; login</li><li>single chat</li></ul><h3 id="start-dev"><a href="#start-dev" class="headerlink" title="start dev:"></a>start dev:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pnpm install &amp;&amp; npm run dev-server &amp;&amp; npm run dev-static</span><br></pre></td></tr></table></figure><p>then open <em>localhost:3000/app</em> in browser.</p><h3 id="build-for-production"><a href="#build-for-production" class="headerlink" title="build for production:"></a>build for production:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose up</span><br></pre></td></tr></table></figure><p>then open <em>localhost/app</em> in browser.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要技术栈&quot;&gt;&lt;a href=&quot;#主要技术栈&quot; class=&quot;headerlink&quot; title=&quot;主要技术栈&quot;&gt;&lt;/a&gt;主要技术栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Indexeddb(Dexie)&lt;/li&gt;
&lt;li&gt;Socket.io&lt;/li&gt;
&lt;li&gt;Nodejs + Express + typeorm + Mysql + Redis&lt;/li&gt;
&lt;li&gt;Pnpm monorepo&lt;/li&gt;
&lt;li&gt;Docker compose + Github Actions CI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现细节请查看github仓库: &lt;a href=&quot;https://github.com/lilong7676/simple-chat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;simple-chat&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://lilong7676.github.io/categories/web/"/>
    
    
      <category term="React" scheme="https://lilong7676.github.io/tags/React/"/>
    
      <category term="Docker" scheme="https://lilong7676.github.io/tags/Docker/"/>
    
      <category term="CI/CD" scheme="https://lilong7676.github.io/tags/CI-CD/"/>
    
      <category term="Indexeddb" scheme="https://lilong7676.github.io/tags/Indexeddb/"/>
    
      <category term="nodejs" scheme="https://lilong7676.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个js浏览器端沙箱</title>
    <link href="https://lilong7676.github.io/2022/01/21/javascript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjs%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E6%B2%99%E7%AE%B1/"/>
    <id>https://lilong7676.github.io/2022/01/21/javascript/如何实现一个js浏览器端沙箱/</id>
    <published>2022-01-21T01:39:16.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是沙箱?基本原理是什么?  </li></ul><p>沙箱的目的其实就是隔离变量,代理某些变量,防止污染宿主环境. </p><a id="more"></a><p>在浏览器中,我们可以利用 js 闭包的能力,利用变量作用域去模拟一个沙箱环境,最简单的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;<span class="attr">document</span>: <span class="string">'fakedocument'</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码的输出肯定是 fakedocument, 而不是浏览器原生的document.  </p><ul><li>实现难点:如何模拟浏览器原生window?</li></ul><p>有两个方案,一是根据 ECMA 规范实现这一堆的浏览器原生对象,显然这个成本太高.<br>所以这里有个取巧的办法,我们可以创建一个 iframe并设置src=”about:blank”,这个时候可以确保 url 同域,也不会发生资源加载.<br>然后取出 iframe 对应的 <strong>contentWindow</strong>,利用其<strong>天然隔离</strong>特性,省去了自己实现的成本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在沙盒环境中执行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evalScript(code: string) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 利用 Function构造函数,构造沙箱环境,给 code 加一层 wrap,创建一个闭包,</span></span><br><span class="line"><span class="comment">   * 把需要隔离的浏览器原生对象变成从函数闭包中获取</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> resolver = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    return function(&#123;window, location, history, document&#125;) &#123;</span></span><br><span class="line"><span class="string">      with(window.__GLOBAL_OVERRIDES_VARS__) &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          (function() &#123;</span></span><br><span class="line"><span class="string">            "use strict";</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">          &#125;)();</span></span><br><span class="line"><span class="string">        &#125; catch(e) &#123;</span></span><br><span class="line"><span class="string">          console.log(e);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">  resolver().call(<span class="keyword">this</span>.window, &#123; ...this &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过proxy 代理 window的访问</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement( <span class="string">'iframe'</span> );</span><br><span class="line">  iframe.src = <span class="string">'about:blank'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options, context, iframe) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(iframe.contentWindow, &#123;</span><br><span class="line">        <span class="keyword">set</span>(target, name, value) &#123;</span><br><span class="line">        target[name] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">        <span class="keyword">switch</span>( name ) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'document'</span>:</span><br><span class="line">            <span class="keyword">return</span> context.document;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> target[ name ] === <span class="string">'function'</span> &amp;&amp; <span class="regexp">/^[a-z]/</span>.test( name ) )&#123;</span><br><span class="line">          <span class="keyword">return</span> target[ name ].bind &amp;&amp; target[ name ].bind( target );</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> target[ name ];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;什么是沙箱?基本原理是什么?  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;沙箱的目的其实就是隔离变量,代理某些变量,防止污染宿主环境. &lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://lilong7676.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS逆向学习</title>
    <link href="https://lilong7676.github.io/2021/05/09/iOS/iOS%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lilong7676.github.io/2021/05/09/iOS/iOS逆向学习/</id>
    <published>2021-05-09T08:20:20.000Z</published>
    <updated>2023-06-08T06:26:43.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p></blockquote><ul><li><a href="https://www.jianshu.com/p/f229f8df3220" target="_blank" rel="noopener">2019年iOS逆向最新学习资料（一）：理论基础和工具准备</a></li><li><a href="https://www.jianshu.com/p/8d42d71fb9e1" target="_blank" rel="noopener">iOS逆向, 基础工具之LLDB和debugserver</a></li><li><a href="https://juejin.cn/post/6844904094360961037" target="_blank" rel="noopener">debugserver+lldb使用</a></li><li><a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">MonkeyDev 文档</a></li><li><a href="https://www.jianshu.com/p/991b13c10c1f" target="_blank" rel="noopener">Cycript 基本使用</a></li><li><a href="https://juejin.cn/post/6942419453879517192" target="_blank" rel="noopener">小谷的足迹2 – iOS逆向安防从入门到秃头</a></li><li><a href="https://blog.csdn.net/qq_34003239/article/details/97625507" target="_blank" rel="noopener">lldb插件 强大的调试神器Chisel</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/f229f8df3220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2019年iOS逆向最
      
    
    </summary>
    
      <category term="iOS" scheme="https://lilong7676.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://lilong7676.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>mac终端实用命令</title>
    <link href="https://lilong7676.github.io/2019/06/12/Shell%E8%84%9A%E6%9C%AC/%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://lilong7676.github.io/2019/06/12/Shell脚本/终端实用命令/</id>
    <published>2019-06-12T00:16:41.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<p>查看该目录下各个文件和子目录各占多少空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure><a id="more"></a><p>批量复制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *.png *.jpeg *.gif /destpath (剪切的话 cp换成 mv)</span><br></pre></td></tr></table></figure><p>快速创建便笺<br>选中文字，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + Y</span><br></pre></td></tr></table></figure><p>保持窗口的激活状态<br>当你在当前窗口操作时，想拖拽其他窗口， 可以按住<code>command</code>再进行拖 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看该目录下各个文件和子目录各占多少空间&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;du -sh *&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell脚本" scheme="https://lilong7676.github.io/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="shell" scheme="https://lilong7676.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>笔记：Shell基本语法</title>
    <link href="https://lilong7676.github.io/2019/06/11/Shell%E8%84%9A%E6%9C%AC/%E7%AC%94%E8%AE%B0%EF%BC%9AShell%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://lilong7676.github.io/2019/06/11/Shell脚本/笔记：Shell基本语法/</id>
    <published>2019-06-11T11:35:01.000Z</published>
    <updated>2023-06-08T06:26:43.567Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.sh</span><br><span class="line">#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行Shell脚本的方法</span><br><span class="line">1 作为可执行程序</span><br><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br><span class="line">    </span><br><span class="line">2 作为解释器参数</span><br><span class="line">/bin/sh test.sh</span><br></pre></td></tr></table></figure><h1 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#定义变量</span><br><span class="line">my_name=&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">#使用变量 只需要在变量名前加上 $ 符号</span><br><span class="line">echo $my_name</span><br><span class="line">#加花括号视为了帮助解释器识别变量的边界</span><br><span class="line">echo $&#123;my_name&#125;</span><br><span class="line"></span><br><span class="line">for skill in Java Coffee; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#使用readonly将变量设为只读变量</span><br><span class="line">my_name=&quot;foo&quot;</span><br><span class="line">readonly my_name #如果尝试修改变量值，会报错</span><br><span class="line">my_name=&quot;bar&quot; #my_name: readonly variable</span><br><span class="line"></span><br><span class="line">#删除变量</span><br><span class="line">#变量被删除后不能再次使用。unset 命令不能删除只读变量。</span><br><span class="line">unset my_name</span><br><span class="line">echo my_name #将没有任何输出</span><br></pre></td></tr></table></figure><h2 id="shell变量类型-三种"><a href="#shell变量类型-三种" class="headerlink" title="shell变量类型 三种"></a>shell变量类型 三种</h2><ol><li>局部变量</li></ol><p>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量</p><ol start="2"><li>环境变量</li></ol><p>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 </p><ol start="3"><li><p>shell变量</p><p>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p><h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> your_name=&quot;foo&quot;</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2=&apos;hello, &apos;$your_name&apos; !&apos;</span><br><span class="line">greeting_3=&apos;hello, $&#123;your_name&#125; !&apos;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">hello, foo ! hello, foo !</span><br><span class="line">hello, foo ! hello, $&#123;your_name&#125; !</span><br><span class="line"></span><br><span class="line">#获取字符串的长度</span><br><span class="line">str=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#str&#125; #输出 4</span><br><span class="line"></span><br><span class="line">#提取子串 </span><br><span class="line">#以下实例从字符串第 2 个字符开始截取 4 个字符</span><br><span class="line">str=&quot;hello world&quot;</span><br><span class="line">echo $&#123;str:1:4&#125; $输出 ello</span><br><span class="line"></span><br><span class="line">#查找子字符串的位置</span><br><span class="line">#查找字符 l 或 o 的位置(哪个字母先出现就计算哪个)：</span><br><span class="line">string=&quot;hello world&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; lo`  # 输出 2</span><br></pre></td></tr></table></figure></li></ol><h3 id="shell-数组"><a href="#shell-数组" class="headerlink" title="shell 数组"></a>shell 数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#数组 数组名=(值1 值2 ... 值n)</span><br><span class="line">arr=(</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br><span class="line">)</span><br><span class="line">echo &quot;数组 $&#123;arr[1]&#125;&quot;</span><br><span class="line">#使用 @ 符号可以获取数组中的所有元素</span><br><span class="line">echo “数组中的所有元素 $&#123;arr[@]&#125;”</span><br><span class="line">#获取数组的长度</span><br><span class="line">echo &quot;数组的长度 $&#123;#arr[@]&#125;&quot;</span><br><span class="line">#或者</span><br><span class="line">echo &quot;数组的长度 $&#123;#arr[*]&#125;&quot;</span><br><span class="line">#获取数组单个元素的长度</span><br><span class="line">echo &quot;数组第二个元素的长度 $&#123;#arr[1]&#125;&quot;</span><br><span class="line"></span><br><span class="line">#还可以单独定义数组的各个分量：</span><br><span class="line"></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><h3 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># $ ./test.sh 1 222 3 4</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;shell 传递参数实例&quot;</span><br><span class="line">echo &quot;执行的文件名 $0&quot;</span><br><span class="line">echo &quot;第一个参数 $1&quot;</span><br><span class="line">echo &quot;第二个参数 $2&quot;</span><br><span class="line">echo &quot;第三个参数 $3&quot;</span><br><span class="line">echo &quot;参数个数 $#&quot;</span><br><span class="line">echo &quot;所有参数 $*&quot;</span><br><span class="line">echo &quot;所有参数 加引号 \&quot;$@\&quot;&quot;</span><br><span class="line">echo &quot;脚本当前进程ID $$&quot;</span><br><span class="line">echo &quot;后台运行的最后一个进程的ID $!&quot;</span><br><span class="line">echo &quot;shell使用的当前选项 $-&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$* 演示--&quot;</span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$@ 演示--&quot;</span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">shell 传递参数实例</span><br><span class="line">执行的文件名 ./test.sh</span><br><span class="line">第一个参数 1</span><br><span class="line">第二个参数 222</span><br><span class="line">第三个参数 3</span><br><span class="line">参数个数 4</span><br><span class="line">所有参数 1 222 3 4</span><br><span class="line">所有参数 加引号 &quot;1 222 3 4&quot;</span><br><span class="line">脚本当前进程ID 20530</span><br><span class="line">后台运行的最后一个进程的ID </span><br><span class="line">shell使用的当前选项 hB</span><br><span class="line">-- $* 演示--</span><br><span class="line">1 222 3 4</span><br><span class="line">-- $@ 演示--</span><br><span class="line">1</span><br><span class="line">222</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="shell算数运算"><a href="#shell算数运算" class="headerlink" title="shell算数运算"></a>shell算数运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">echo &quot;a $a, b $b&quot;</span><br><span class="line"></span><br><span class="line">#加法</span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b: $val&quot;</span><br><span class="line"></span><br><span class="line">#乘法 需要转义</span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b: $val&quot;</span><br><span class="line"></span><br><span class="line">#除法</span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a: $val&quot;</span><br><span class="line"></span><br><span class="line">#取余</span><br><span class="line">val=`expr $a % $b`</span><br><span class="line">echo &quot;a % b: $val&quot;</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">a 10, b 20</span><br><span class="line">a + b: 30</span><br><span class="line">a * b: 200</span><br><span class="line">b / a: 2</span><br><span class="line">a % b: 10</span><br><span class="line">a 不等于 b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#扩展 三种加法运算写法</span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">c=`expr $a + $b`</span><br><span class="line"></span><br><span class="line">echo &quot;c: $c&quot;</span><br><span class="line"></span><br><span class="line">d=$[ `expr $a + $b` ]</span><br><span class="line">echo &quot;d: $d&quot;</span><br><span class="line"></span><br><span class="line">e=$[ 10 + 20 ]</span><br><span class="line">echo &quot;e: $e&quot;</span><br></pre></td></tr></table></figure><h3 id="shell-关系运算符"><a href="#shell-关系运算符" class="headerlink" title="shell 关系运算符"></a>shell 关系运算符</h3><p>假设变量a=10 b=20</p><table><thead><tr><th>运算符</th><th>说明</th><th>用法示例</th></tr></thead><tbody><tr><td>-eq</td><td>检测两个数是否相等</td><td>[ $a -eq $b ] 返回 false</td></tr><tr><td>-nq</td><td>检测两个数是否不相等</td><td>[ $a -nq $b]</td></tr><tr><td>-gt</td><td>&gt;</td><td></td></tr><tr><td>-lg</td><td>&lt;</td><td></td></tr><tr><td>-ge</td><td>&gt;=</td><td></td></tr><tr><td>-le</td><td>&lt;=</td><td></td></tr></tbody></table><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>!</td><td>非运算</td><td>[ !false ] 返回true</td></tr><tr><td>-o</td><td>或运算</td><td>[ $a -lt 20 -o $b -gt 100]</td></tr><tr><td>-a</td><td>与运算</td><td></td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑AND</td><td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</td></tr><tr><td>`</td><td></td><td>`</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>假设变量a=”abc” b=”efg”</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等</td><td>[ $a =$b ]返回false</td></tr><tr><td>!=</td><td></td><td></td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回true</td><td>[ -z $a ] false</td></tr><tr><td>-n</td><td>检测字符串长度是否不为0</td><td>[ -n “$a” ] true</td></tr><tr><td>str</td><td>检测字符串是否为空，不为空返回true</td><td>[ $a ] true</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 [[ ... ]] 条件判断结构，而不是 [ ... ]，能够防止脚本中的许多逻辑错误。</span><br><span class="line">比如，&amp;&amp;、||、&lt; 和 &gt; 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话，会报错。</span><br></pre></td></tr></table></figure><h3 id="printf输出"><a href="#printf输出" class="headerlink" title="printf输出"></a>printf输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">printf 命令模仿 C 程序库（library）里的 printf() 程序。</span><br><span class="line"></span><br><span class="line">printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</span><br><span class="line"></span><br><span class="line">printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</span><br><span class="line"></span><br><span class="line">printf 命令的语法：</span><br><span class="line"></span><br><span class="line">printf  format-string  [arguments...]</span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">format-string: 为格式控制字符串</span><br><span class="line">arguments: 为参数列表。</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 </span><br><span class="line"></span><br><span class="line"># format-string为双引号</span><br><span class="line">printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</span><br><span class="line"></span><br><span class="line"># 单引号与双引号效果一样 </span><br><span class="line">printf &apos;%d %s\n&apos; 1 &quot;abc&quot; </span><br><span class="line"></span><br><span class="line"># 没有引号也可以输出</span><br><span class="line">printf %s abcdef</span><br><span class="line"></span><br><span class="line"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s\n&quot; abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s %s %s\n&quot; a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="line">printf &quot;%s and %d \n&quot;</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br><span class="line">1 abc</span><br><span class="line">1 abc</span><br><span class="line">abcdefabcdefabc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j  </span><br><span class="line"> and 0</span><br></pre></td></tr></table></figure><h3 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h3><p>if 条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if test $a -lt $b; then</span><br><span class="line">printf &apos;%s\n&apos; &quot;a &lt; b&quot;</span><br><span class="line">elif [[ $a -gt $b ]]; then</span><br><span class="line">echo &quot;a &gt; b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>for 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for a in 1 2 3 4 5; do</span><br><span class="line">echo $a  #不要忘了变量前加 $</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#第二种写法,类似于C语言写法</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">    echo &quot;这是第 $i 次调用&quot;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p>while 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">while(( $i&lt;5 ))</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">i=`expr $i + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>until 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>case 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">case的语法和C family语言差别很大</span><br><span class="line">它需要一个esac（就是case反过来）作为结束标记</span><br><span class="line">每个case分支用右圆括号，用两个分号表示break。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &apos;输入 1 到 4 之间的数字:&apos;</span><br><span class="line">echo &apos;你输入的数字为:&apos;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in               #变量后面必须跟上 in</span><br><span class="line">    1)  echo &apos;你选择了 1&apos;   #每一个模式必须以右括号结束</span><br><span class="line">    ;;                      #相当于break;</span><br><span class="line">    2)  echo &apos;你选择了 2&apos;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &apos;你选择了 3&apos;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &apos;你选择了 4&apos;</span><br><span class="line">    ;;</span><br><span class="line">    # * 相当于 default</span><br><span class="line">    *)  echo &apos;你没有输入 1 到 4 之间的数字&apos;</span><br><span class="line">    ;;</span><br><span class="line">esac    #结束case</span><br></pre></td></tr></table></figure><p>跳出循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#定义函数</span><br><span class="line">demoFun()&#123;</span><br><span class="line">echo &quot;第一个shell函数&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#执行函数</span><br><span class="line">demoFun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###带返回值的函数</span><br><span class="line">funcWithReturn () &#123;</span><br><span class="line">echo &quot;输入a&quot;</span><br><span class="line">read a</span><br><span class="line">echo &quot;输入b&quot;</span><br><span class="line">read b</span><br><span class="line"></span><br><span class="line">echo -e &quot;a + b = \c&quot;</span><br><span class="line">return $(($a + $b))</span><br><span class="line">&#125;</span><br><span class="line">#执行函数</span><br><span class="line">funcWithReturn</span><br><span class="line">#通过 $?获取函数执行后的返回值</span><br><span class="line">echo &quot;$?&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###给函数传参</span><br><span class="line">funWithParam () &#123;</span><br><span class="line">echo $@</span><br><span class="line">echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">i=1</span><br><span class="line">for arg in $@; do</span><br><span class="line">echo &quot;第$&#123;i&#125;个参数为 $arg&quot;</span><br><span class="line">i=$(($i+1))</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funWithParam 1 2 3 4 5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// test.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell脚本" scheme="https://lilong7676.github.io/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="shell" scheme="https://lilong7676.github.io/tags/shell/"/>
    
  </entry>
  
</feed>
